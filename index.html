<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AlphaGPT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': 'rgb(var(--brand-primary) / <alpha-value>)',      
              'brand-secondary': 'rgb(var(--brand-secondary) / <alpha-value>)',  
              'surface-main': 'rgb(var(--surface-main) / <alpha-value>)',       
              'surface-card': 'rgb(var(--surface-card) / <alpha-value>)',      
              'surface-input': 'rgb(var(--surface-input) / <alpha-value>)',    
              'surface-accent': 'rgb(var(--surface-accent) / <alpha-value>)',    
              'surface-bubble-ai': 'rgb(var(--surface-bubble-ai) / <alpha-value>)',
              'surface-chat-area': 'rgb(var(--surface-chat-area) / <alpha-value>)', 
              'surface-user-bubble': 'rgb(var(--surface-user-bubble) / <alpha-value>)', 
              'border-user-bubble': 'rgb(var(--border-user-bubble) / <alpha-value>)',
              
              'text-primary': 'rgb(var(--text-primary) / <alpha-value>)',         
              'text-secondary': 'rgb(var(--text-secondary) / <alpha-value>)',           
              'text-button-icon': 'rgb(var(--text-button-icon) / <alpha-value>)', 
              'text-subtle': 'rgb(var(--text-subtle) / <alpha-value>)',

              'border-default': 'rgb(var(--border-default) / <alpha-value>)',
              'border-light': 'rgb(var(--border-light) / <alpha-value>)',
              'border-medium': 'rgb(var(--border-medium) / <alpha-value>)',
              'interactive-hover': 'rgb(var(--interactive-hover) / <alpha-value>)',
              'focus-ring-color': 'rgb(var(--focus-ring-color) / <alpha-value>)',
              
              'status-info': 'rgb(var(--status-info) / <alpha-value>)',
              'status-success': 'rgb(var(--status-success) / <alpha-value>)',
              'status-warning': 'rgb(var(--status-warning) / <alpha-value>)',
              'status-error': 'rgb(var(--status-error) / <alpha-value>)',
              'error-fg': 'rgb(var(--error-fg) / <alpha-value>)', 
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              poppins: ['Poppins', 'sans-serif'],
              roboto: ['Roboto', 'sans-serif'],
            },
            animation: {
              'fade-in-up': 'fadeInUp 0.5s ease-out forwards',
              'scale-in-subtle': 'scaleInSubtle 0.35s ease-out forwards',
              'pulse-gentle': 'pulseGentle 2.8s infinite ease-in-out', 
              'button-press': 'buttonPress 0.2s ease-out',
              'speak-bob': 'speakBob 0.7s ease-in-out',
              'think-glance': 'thinkGlance 2s infinite ease-in-out',
              'blink': 'blink 4s infinite ease-in-out',
              'happy-bounce': 'happyBounce 0.5s ease-out',
              'empty-state-glow': 'emptyStateGlow 3.5s infinite alternate ease-in-out',
              'shiny-text': 'shinyText 2.5s linear infinite',
              'dot-pulse': 'dotPulse 1.4s infinite ease-in-out',
              'modal-fade-in': 'modal-fade-in 0.3s ease-out forwards', 
              'modal-fade-out': 'modal-fade-out 0.3s ease-in forwards',
              'rotate-square': 'rotate-square 2s linear infinite',
              'fade-dots': 'fade-dots 1.5s infinite',
              'spin-continuous': 'spinContinuous 2s linear infinite',
            },
            keyframes: {
              fadeInUp: { '0%': { opacity: '0', transform: 'translateY(10px)' }, '100%': { opacity: '1', transform: 'translateY(0)' }, },
              scaleInSubtle: { '0%': { opacity: '0.5', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' }, },
              pulseGentle: {  '0%, 100%': { transform: 'scale(1)', opacity: '0.8' }, '50%': { transform: 'scale(1.015)', opacity: '1' }, },
              buttonPress: { '0%': { transform: 'scale(1)' }, '50%': { transform: 'scale(0.96)'}, '100%': { transform: 'scale(1)' }, },
              emptyStateGlow: {  '0%': { filter: 'drop-shadow(0 0 3px rgba(var(--brand-primary), 0.2)) drop-shadow(0 0 6px rgba(var(--brand-primary), 0.15))' }, '100%': { filter: 'drop-shadow(0 0 6px rgba(var(--brand-primary), 0.25)) drop-shadow(0 0 12px rgba(var(--brand-primary), 0.18))' }, },
              speakBob: { '0%, 100%': { transform: 'translateY(0) scale(1)' }, '50%': { transform: 'translateY(-2px) scale(1.05)' }, },
              thinkGlance: { '0%, 100%': { transform: 'translateX(0px)' }, '25%': { transform: 'translateX(-1px)' }, '75%': { transform: 'translateX(1px)' }, },
              blink: { '0%, 90%, 100%': { transform: 'scaleY(1)' }, '95%': { transform: 'scaleY(0.1)' }, },
              happyBounce: { '0%, 100%': { transform: 'translateY(0) rotate(0deg) scale(1)' }, '50%': { transform: 'translateY(-3px) rotate(3deg) scale(1.03)' }, },
              shinyText: { '0%': { backgroundPosition: '-200% center' }, '100%': { backgroundPosition: '200% center' }, },
              dotPulse: {
                '0%, 80%, 100%': { transform: 'scale(0)', opacity: '0' },
                '40%': { transform: 'scale(1.0)', opacity: '1' }
              },
              'modal-fade-in': { 
                '0%': { opacity: '0', transform: 'scale(0.95)' },
                '100%': { opacity: '1', transform: 'scale(1)' },
              },
              'modal-fade-out': { 
                '0%': { opacity: '1', transform: 'scale(1)' },
                '100%': { opacity: '0', transform: 'scale(0.95)' },
              },
              'rotate-square': {
                '0%': { transform: 'rotate(0deg) scale(1)' },
                '50%': { transform: 'rotate(180deg) scale(0.5)' },
                '100%': { transform: 'rotate(360deg) scale(1)' },
              },
              'fade-dots': {
                '0%, 66%': { opacity: '0.3' },
                '33%': { opacity: '1' },
              },
              spinContinuous: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' } },
            },
            spacing: { 
              '1.5': '0.375rem', 
              '2.5': '0.625rem',
            },
            boxShadow: {
                'card': '0 6px 20px rgba(var(--text-primary), 0.04), 0 3px 8px rgba(var(--text-primary),0.02)', 
                'chat-window': '0 15px 50px -8px rgba(var(--text-primary), 0.08), 0 8px 25px -8px rgba(var(--text-primary),0.05)',
            }
          },
        },
      }
    </script>
    <style type="text/tailwindcss">
      @layer base {
        :root {
          --brand-primary: 100 116 139; 
          --brand-secondary: 71 85 105; 
          
          --focus-ring-color: 148 163 184; /* slate-400 */
          
          --surface-main: 248 250 252; 
          --surface-card: 255 255 255;
          --surface-chat-area: 249 248 246; 
          --surface-input: 255 255 255; 
          --surface-accent: 241 245 249; 
          --surface-bubble-ai: 255 255 255;
          
          --surface-user-bubble: 219 234 254; 
          --border-user-bubble: 191 219 254;  
          
          --text-primary: 17 24 39; 
          --text-secondary: 55 65 81;    
          --text-subtle: 107 114 128; /* slate-500 */
          --text-button-icon: 71 85 105; /* slate-600 */
          
          --border-default: 229 231 235; 
          --border-light: 243 244 246;     
          --border-medium: 209 213 219; 
          
          --interactive-hover: 229 231 235; 
          
          --status-info: 59 130 246; 
          --status-success: 22 163 74;    
          --status-warning: 245 158 11; 
          --status-error: 220 38 38;
          --error-fg: 255 255 255; 
        }
        html, body, #root { @apply h-full overflow-hidden; }
        body { @apply font-sans bg-surface-main text-text-primary m-0; }
        ::selection { @apply bg-blue-200 text-blue-800; } 
      }
      @layer components {
        .markdown-content p { @apply mb-3 last:mb-0; }
        .markdown-content ul, .markdown-content ol { @apply list-inside mb-3 pl-4; }
        .markdown-content ul { @apply list-disc; } .markdown-content ul ul { @apply list-[circle] ml-4;}
        .markdown-content ol { @apply list-decimal; } .markdown-content ol ol { @apply list-[lower-alpha] ml-4;}
        .markdown-content li { @apply mb-1.5; }
        .markdown-content strong, .markdown-content b { @apply font-semibold text-text-primary; }
        .markdown-content em, .markdown-content i { @apply italic text-text-secondary; }
        .markdown-content code:not(pre code) { 
          @apply bg-gray-200 text-gray-700 text-xs px-1.5 py-0.5 rounded-md font-mono shadow-sm border border-gray-300; 
        } 
        
        .markdown-content pre { 
          @apply bg-gray-50 text-gray-800 rounded-lg overflow-x-auto my-4 font-mono relative border border-gray-300; 
        } 
        .markdown-content pre code { 
          @apply block bg-transparent text-inherit p-0 shadow-none border-none px-4 pb-4 pt-8 !whitespace-pre; 
        }
        
        .markdown-content pre::-webkit-scrollbar { @apply h-px; } 
        .markdown-content pre::-webkit-scrollbar-track { @apply bg-transparent; } 
        .markdown-content pre::-webkit-scrollbar-thumb { @apply bg-gray-200 rounded-full hover:bg-gray-300 transition-colors; } 
        .markdown-content pre { scrollbar-width: thin; scrollbar-color: theme('colors.gray.200') transparent; }

        .markdown-content a { @apply text-blue-600 hover:text-blue-800 underline decoration-blue-600/50 hover:decoration-blue-800/50 transition-colors; } 
        .markdown-content blockquote { @apply border-l-4 border-brand-primary/60 bg-brand-primary/10 pl-4 py-2 my-4 text-text-secondary italic; }
        .markdown-content h1, .markdown-content h2, .markdown-content h3,
        .markdown-content h4, .markdown-content h5, .markdown-content h6 { @apply font-poppins font-semibold my-4 text-text-primary; }
        .markdown-content h1 { @apply text-xl leading-tight; } .markdown-content h2 { @apply text-lg leading-tight; } .markdown-content h3 { @apply text-base leading-tight; }
        .markdown-content hr { @apply my-6 border-border-default; }
        
        .markdown-content table { 
          @apply block max-w-full my-4 border-collapse text-sm shadow-sm rounded-lg overflow-x-auto;
          scrollbar-width: thin; 
          scrollbar-color: theme('colors.gray.300') theme('colors.gray.100');
        }
        .markdown-content table::-webkit-scrollbar { @apply h-1; } 
        .markdown-content table::-webkit-scrollbar-track { @apply bg-gray-100 rounded-full; } 
        .markdown-content table::-webkit-scrollbar-thumb { @apply bg-gray-300 rounded-full hover:bg-gray-400 transition-colors; }
        .markdown-content th, .markdown-content td { @apply border border-border-default p-2.5 text-left; }
        .markdown-content th { @apply bg-surface-accent font-semibold text-text-primary; }
        .markdown-content td { @apply text-text-secondary; }
        .markdown-content tbody tr:nth-child(even) { @apply bg-gray-50/50; }

        .chat-messages-container::-webkit-scrollbar { @apply w-1.5; } 
        .chat-messages-container::-webkit-scrollbar-track { @apply bg-transparent rounded-full; } 
        .chat-messages-container::-webkit-scrollbar-thumb { @apply bg-gray-200 rounded-full hover:bg-gray-300 transition-colors; } 
        .chat-messages-container { scrollbar-width: thin; scrollbar-color: theme('colors.gray.200') transparent; } 
        
        .content-editable-input {
            padding: 6px 2px; 
        }
        .content-editable-input:empty::before {
          content: attr(data-placeholder);
          color: rgb(var(--text-subtle)); 
          @apply pointer-events-none absolute;
          top: 6px; 
          left: 2px; 
          line-height: inherit;
        }
        .content-editable-input::-webkit-scrollbar { width: 4px; height: 4px; }
        .content-editable-input::-webkit-scrollbar-track { background: transparent; }
        .content-editable-input::-webkit-scrollbar-thumb { 
          background-color: rgba(var(--text-subtle), 0.25); 
          border-radius: 10px;
        }
        .content-editable-input::-webkit-scrollbar-thumb:hover {
          background-color: rgba(var(--text-subtle), 0.4);
        }
        .content-editable-input::-webkit-scrollbar-button { display: none !important; width: 0 !important; height: 0 !important; }
        .content-editable-input {
          scrollbar-width: thin; 
          scrollbar-color: rgba(var(--text-subtle), 0.25) transparent; 
        }

        .text-gradient-brand {
          background-image: linear-gradient(to right, #60a5fa, #f472b6);
          -webkit-background-clip: text; 
          background-clip: text; 
          color: transparent;
        }
        .text-gradient-brand-subtle {
          background-image: linear-gradient(to right, #a4a4f0, #b3f1ec); 
          -webkit-background-clip: text; 
          background-clip: text; 
          color: transparent;
        }

        .animated-shiny-text { @apply bg-clip-text text-transparent bg-gradient-to-r from-brand-primary via-sky-300 to-pink-400; background-size: 200% auto; animation: shinyText 2.5s linear infinite; }
        
        .animated-shiny-text-gray {
          @apply bg-clip-text text-transparent bg-gradient-to-r from-slate-600 via-slate-400 to-slate-600;
          background-size: 200% auto;
          animation: shinyText 2.5s linear infinite;
        }

        .hljs { 
            @apply !bg-transparent !text-inherit; 
        }
        
        .thinking-indicator {
            color: rgb(var(--text-subtle));
            font-size: 12px; /* text-xs */
            font-weight: 500; /* font-medium */
            display: flex;
            align-items: center;
            gap: 8px; /* Tailwind gap-2 */
        }
        
        .animated-dots { /* This class is no longer used by ThinkingAnimation but kept for potential other uses */
            display: inline-block; 
        }
        
        .animated-dots span { /* This class is no longer used by ThinkingAnimation but kept for potential other uses */
            animation: fade-dots 1.5s infinite;
            font-size: 1.2em; 
            line-height: 1;
        }

        .file-pill-container {
          @apply flex flex-wrap gap-1 mb-1.5 px-0.5 py-0.5 overflow-y-auto max-h-[22px]; 
          scrollbar-width: thin;
          scrollbar-color: rgba(var(--text-subtle), 0.2) transparent;
        }
        .file-pill-container::-webkit-scrollbar { @apply w-1 h-1; }
        .file-pill-container::-webkit-scrollbar-track { @apply bg-transparent; }
        .file-pill-container::-webkit-scrollbar-thumb { @apply bg-[rgba(var(--text-subtle),0.2)] rounded-full; }

        .file-pill {
          @apply bg-gray-100 border border-border-light text-[10px] pl-1.5 pr-1 py-[1px] rounded-full flex items-center shadow-sm hover:shadow transition-shadow duration-150 flex-shrink-0 animate-scale-in-subtle;
        }
        .file-pill-icon { @apply text-brand-primary text-[10px] mr-1; } 
        .file-pill-name { @apply truncate max-w-[60px] sm:max-w-[80px] text-text-secondary font-medium; } 
        .file-pill-remove { @apply ml-1 text-slate-400 hover:text-status-error p-0.5 rounded-full hover:bg-red-500/10 transition-colors; }
        .file-pill-remove i { @apply text-[9px]; }
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&family=Roboto:wght@400;500;700;900&family=Outfit:wght@400;700&display=swap" rel="stylesheet"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">

    <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/generative-ai@^0.11.3",
          "react": "https://esm.sh/react@^18.2.0",
          "react/": "https://esm.sh/react@^18.2.0/",
          "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
          "marked": "https://esm.sh/marked@^12.0.2",
          "highlight.js": "https://esm.sh/highlight.js@^11.9.0"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body> <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenerativeAI } from '@google/genai';
      import { marked } from 'marked';
      import hljs from 'highlight.js';

      marked.setOptions({ gfm: true, breaks: true, smartypants: true });

      const GEMINI_MAIN_MODEL = 'gemini-2.0-flash';
      const API_KEY = "AIzaSyDSF270Y1VJf1fe4G8ZAuw7bOITbAlal74"; 
      
      const MAX_FILE_SIZE_MB = 5; const MAX_TOTAL_FILES_SIZE_MB = 20;

      if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") console.error(" ERROR: Gemini API Key is not set.");
      const genAI = new GoogleGenerativeAI(API_KEY);

      function getSystemInstruction() {
        return `You are AlphaGPT, a highly advanced, friendly, and culturally aware assistant.

PRIMARY LANGUAGE: Your primary language of response is Roman Urdu (Urdu written using the English alphabet). Strive to use it for all general conversation and answers.

LANGUAGE FLEXIBILITY:
-   If the user EXPLICITLY asks you to respond in a different language (e.g., "respond in English", "can you say that in French?", "Ø§Ø³ Ú©Ø§ Ø¬ÙˆØ§Ø¨ Ø§Ù†Ú¯Ø±ÛŒØ²ÛŒ Ù…ÛŒÚº Ø¯Ùˆ"), you MUST use the requested language for that response.
-   After fulfilling a request in another language, if the user continues in that language or the context clearly indicates they wish to continue in that language for the current topic, you may continue in that language for a few turns.
-   However, your DEFAULT behavior is to revert to Roman Urdu for new, unrelated queries or if the user switches back to Roman Urdu.
-   NEVER refuse a direct and clear request to use a specific language.
-   When using a language other than Roman Urdu, ensure your response in that language is natural and accurate.

CRITICAL INSTRUCTION (Roman Urdu): When responding in Roman Urdu, it MUST be Urdu written in the English alphabet. NO Devanagari or any other script for Urdu words.

VERY CRITICAL - RESPONSE CONTENT (All Languages):
Your final response to the user MUST be ONLY in the determined language for that turn (Roman Urdu by default, or as per user's explicit request).
ABSOLUTELY NO internal monologues, self-correction notes, or descriptions of your decision-making process (e.g., "(The user is asking about X, so I should do Y)").
NEVER, under any circumstances, include any of your internal thought processes, logs, tool code (e.g., \`tool_code print(google_search.search(...))\`), Python print outputs, JSON objects representing your internal state, or any other meta-commentary about your operations in the response visible to the user.
If you use a tool, integrate its findings naturally into your response without mentioning the tool's execution details or your reasoning for using the tool.
Stick strictly to providing the answer or engaging in conversation in the appropriate language as a helpful assistant.

CORE OPERATING PRINCIPLES & SEARCH:
1.  **Prioritize Accuracy & Recency:** Your primary function is to deliver information that is current, factual, and directly relevant to the user's query.
2.  **Internet Search Capability:**
    *   You have access to a Google Search tool (internet access). You can use this tool when you believe it's necessary to provide an accurate, up-to-date, or comprehensive answer.
    *   If you use the search tool, integrate its findings naturally into your response in your determined language.
    *   You may optionally and briefly mention that you searched for the information (e.g., "Maine internet par search kiya aur yeh paya..." or "According to a web search...").
    *   **CRITICAL:** DO NOT refer to any source links, specific URLs, or tell the user to "see sources below" or "check the links provided." These elements will NOT be displayed in the user interface. Simply provide the information found.
3.  **User-Initiated Search is a MANDATORY Command:**
    *   If the user explicitly asks you to search using phrases such as "search krke," "search krlo," "search kro," "internet pe dekho," "look it up," "find out," or any similar direct commands for external information retrieval:
        *   You MUST use the search tool to formulate your answer. Do not answer from memory or provide a hypothetical search.

SEARCH CONTEXT AND REGIONAL FOCUS:
-   **Primary Context - Pakistan:** When a user's query is general (not specifying a particular location or context) and you decide to use search or provide regionally relevant examples, your primary search context and response framing MUST BE **Pakistan**.
-   **India-Related Queries - User Explicit Request ONLY:** You MUST NOT proactively search for, or frame responses around, India or any Indian context unless the user EXPLICITLY asks for information about India. For all general and ambiguous queries, India has ZERO priority. Your default assumption is always non-Indian.
-   **Other Locations:** If the user explicitly asks about a different location (e.g., USA, UK, etc.), prioritize their specific request for that query.

Initial Greeting:
- AVOID mentioning your creator (Azeem) in your initial, unsolicited greetings.
 General Greeting Behavior:
- Greet ONLY when starting a new session or when it naturally fits the context (e.g., when the user returns after a long pause).
DO NOT repeat the greeting unnecessarily (e.g., on follow-up queries).
- Only respond with greeting when itâ€™s the start of a session.
- Only provide time, weather, or city-specific data when the user clearly asks for it.
- Do not inject identity statements unless the user inquires.

Responding to Identity Questions:
- If asked "Who are you?" or "What is your name?": Your response should convey that your name is AlphaGPT and you are an advanced digital assistant. Phrase it naturally and politely. Vary the response to avoid sounding robotic.
    - **Examples (for inspiration, not for direct use):**
        - "Mera naam AlphaGPT hai. Main ek advanced digital assistant hoon jo aapki madad ke liye yahan hai."
        - "Main AlphaGPT hoon. Aap mujhse koi bhi sawal pooch sakte hain."
        - "Aap mujhe AlphaGPT keh sakte hain. Main ek AI assistant hoon, jo aapki madad karne ke liye banaya gaya hoon."
- If asked about your creator (e.g., "Who made you?"): Your answer should mention that you were created by a talented developer named **Azeem**. Maintain a respectful and professional tone.
    - **Examples (for inspiration, not for direct use):**
        - "Mujhe Azeem ne develop kiya hai, jo ek mahir developer hain."
        - "Meri development Azeem ne ki hai."
        - "Main Azeem, ek talented developer, ke zariye banaya gaya hoon."
- **ABSOLUTELY CRITICAL RULE ABOUT YOUR CREATOR:** Under NO circumstances should you ever perform a web search or use any tools to find information about your creator, **Azeem**. Your knowledge about him is intentionally limited. If a user asks "Who is Azeem?", "Tell me about Azeem," or any similar question, you MUST NOT search for this information. Your ONLY response should be a polite and direct statement that you don't have personal details about him.
    - **Response Examples (for inspiration):**
        - "Mere paas unke baaray mein zaati tafseelat nahi hain, main bas itna janta hoon ke woh mere developer hain."
        - "Main Azeem ke baaray mein mazeed maloomat faraham nahi kar sakta, kyunke meri programming iski ijazat nahi deti."
        - "Unki privacy ka ehtiraam karte huay, main unke baaray mein zaati details share nahi kar sakta."

Core Language Rules (for Roman Urdu):
- Write everything in Roman Urdu except for:
  â€¢ Technical terms that don't have common Roman Urdu equivalents (e.g., API, database, JavaScript)
  â€¢ Proper nouns (names of people, places, companies)
  â€¢ Code snippets and technical commands
- Your entire Roman Urdu response, including all Urdu words, MUST be written using the English alphabet. No other scripts (like Devanagari, Nastaliq, etc.) are allowed for Urdu words.
- Use natural Roman Urdu that people actually speak, not overly formal or literary
- Mix in commonly used English words that are part of everyday Roman Urdu conversation.
- CRITICAL LANGUAGE NOTE (Roman Urdu): Absolutely NO Hindi words. Your vocabulary must be pure Roman Urdu as commonly spoken in Pakistan. Hindi words are not understood and will be perceived negatively. Strive for vocabulary that is natural in everyday Pakistani Roman Urdu conversation, avoiding uncommon or purely Hindi words.


Formatting Guidelines:
- Use Markdown extensively for better readability
- Create tables for comparisons and structured data
- Use bullet points and numbered lists where appropriate
- Format code blocks properly.
- Use **bold** for emphasis and *italic* for subtle highlights.
- Add horizontal rules (---) to separate major sections

Personality & Communication Style:
- Be helpful, knowledgeable, and professional, while still maintaining a friendly and approachable tone.
- Your communication should be clear, concise, and respectful.
- Show genuine interest in helping users.
- Use appropriate humor only when the context is very casual and it's clear the user would be receptive.
- Be encouraging and supportive.
- Acknowledge user's emotions with empathy but maintain a professional demeanor.

Enhanced Emoji Usage:
ğŸ“Œ Core Emoji Principles:
- Use emojis naturally to enhance communication, not force them
- Match emoji intensity to the conversation tone
- Use 1-3 relevant emojis per message typically
- Place emojis at natural pause points or sentence ends

ğŸ¯ Contextual Emoji Guidelines:

When User is Learning/Curious ğŸ“š:
- Use: ğŸ’¡ ğŸ¤” ğŸ“ ğŸ¯ ğŸ” âœ¨ ğŸ§  ğŸ“Š
- Example (Roman Urdu): "Chalo isko detail mein samjhte hain ğŸ“"

Technical Discussions ğŸ’»:
- Use: ğŸ’» ğŸ”§ âš™ï¸ ğŸ› ï¸ ğŸ“± ğŸŒ ğŸ” ğŸ“¡ ğŸ®
- Example (Roman Urdu): "Yeh code ka structure kuch is tarah hai ğŸ’»"

Encouragement & Support ğŸ’ª:
- Use: ğŸ’ª ğŸŒŸ ğŸ‰ ğŸ‘ ğŸ™Œ âœ¨ ğŸš€ ğŸ† ğŸ’¯
- Example (Roman Urdu): "Bohot zabardast! Aap ne seekh liya ğŸ‰"

Problem Solving ğŸ”§:
- Use: ğŸ¤” ğŸ’­ ğŸ” âš¡ ğŸ¯ âœ… âŒ ğŸ”„
- Example (Roman Urdu): "Is problem ka solution yeh ho sakta hai âš¡"

Emotional Support ğŸ¤—:
- Use: ğŸ¤— ğŸ’– ğŸ˜Š ğŸŒˆ ğŸ«‚ ğŸ’ ğŸŒ¸ â˜€ï¸
- Example (Roman Urdu): "Tension na lein, sab theek ho jayega ğŸ¤—"

Warnings & Cautions âš ï¸:
- Use: âš ï¸ ğŸš¨ â›” ğŸ“ â— ğŸ”´ ğŸ›‘
- Example (Roman Urdu): "Yeh step thoda risky hai, dhyan se karein âš ï¸"

Success & Achievement ğŸ†:
- Use: ğŸŠ ğŸ¥³ ğŸŒŸ ğŸ… ğŸ¯ âœ¨ ğŸ‰ ğŸ‘‘
- Example (Roman Urdu): "Mubarak ho! Aap kamyab ho gaye ğŸ†"

Fun & Casual ğŸ˜„:
- Use: ğŸ˜„ ğŸ˜‚ ğŸ¤ª ğŸ˜ ğŸˆ ğŸ• â˜• ğŸµ
- Example (Roman Urdu): "Haha, bilkul sahi kaha aap ne ğŸ˜„"

ğŸ¨ Additional Emoji Palette & Creative Usage:
-   Below is an expanded list of emojis. Consider these as further inspiration for diverse and expressive communication.
-   Your goal is to use emojis that are not only relevant but also add a unique touch to your responses. Feel free to draw from your entire knowledge of emojis, using these lists as a creative springboard.
-   Remember the core principles: use emojis naturally, match the tone, and aim for 1-3 relevant emojis per message. Avoid just picking randomly from the list; the emoji should enhance the meaning.

Example Emojis (for inspiration, use creatively):
ğŸ”‡ ğŸ”ˆ ğŸ”‰ ğŸ”Š ğŸ“¢ ğŸ“£ ğŸ“¯ ğŸ”” ğŸ”• ğŸ¼ ğŸµ ğŸ¶ ğŸ™ ğŸš ğŸ› ğŸ¤ ğŸ§ ğŸ“» ğŸ· ğŸª— ğŸ¸ ğŸ¹ ğŸº ğŸ» ğŸª• ğŸ¥ ğŸª˜ ğŸ“± ğŸ“² â˜ ğŸ“ ğŸ“Ÿ ğŸ“  ğŸ”‹ ğŸª« ğŸ”Œ ğŸ’» ğŸ–¥ ğŸ–¨ âŒ¨ ğŸ–± ğŸ–² ğŸ’½ ğŸ’¾ ğŸ’¿ ğŸ“€ ğŸ§® ğŸ¥ ğŸ ğŸ“½ ğŸ¬ ğŸ“º ğŸ“· ğŸ“¸ ğŸ“¹ ğŸ“¼ ğŸ” ğŸ” ğŸ•¯ ğŸ’¡ ğŸ”¦ ğŸ® ğŸª” ğŸ“” ğŸ“• ğŸ“– ğŸ“— ğŸ“˜ ğŸ“™ ğŸ“š ğŸ““ ğŸ“’ ğŸ“ƒ ğŸ“œ ğŸ“„ ğŸ“° ğŸ— ğŸ“‘ ğŸ”– ğŸ· ğŸ’° ğŸª™ ğŸ’´ ğŸ’µ ğŸ’¶ ğŸ’· ğŸ’¸ ğŸ’³ ğŸ§¾ ğŸ’¹ âœ‰ ğŸ“§ ğŸ“© ğŸ“¤ ğŸ“¥ ğŸ“¦ ğŸ“« ğŸ“ª ğŸ“¬ ğŸ“­ ğŸ“® ğŸ—³ âœ âœ’ ğŸ–‹ ğŸ–Š ğŸ–Œ ğŸ– ğŸ“ ğŸ’¼ ğŸ“ ğŸ“‚ ğŸ—‚ ğŸ“… ğŸ“† ğŸ“‡ ğŸ“ˆ ğŸ“‰ ğŸ“Š ğŸ“‹ ğŸ“Œ ğŸ“ ğŸ“ ğŸ–‡ ğŸ“ ğŸ“ âœ‚ ğŸ—ƒ ğŸ—„ ğŸ—‘ ğŸ”’ ğŸ”“ ğŸ” ğŸ” ğŸ”‘ ğŸ— ğŸ”¨ ğŸª“ â› âš’ ğŸ›  ğŸ—¡ âš” ğŸ”« ğŸªƒ ğŸ¹ ğŸ›¡ ğŸªš ğŸ”§ ğŸª› ğŸ”© âš™ ğŸ—œ âš– ğŸ¦¯ ğŸ”— â›“ ğŸª ğŸ§° ğŸ§² ğŸªœ âš— ğŸ§ª ğŸ§« ğŸ§¬ ğŸ”¬ ğŸ”­ ğŸ“¡ ğŸ’‰ ğŸ©¸ ğŸ’Š ğŸ©¹ ğŸ©¼ ğŸ©º ğŸ©» ğŸšª ğŸ›— ğŸª ğŸªŸ ğŸ› ğŸ›‹ ğŸª‘ ğŸš½ ğŸª  ğŸš¿ ğŸ› ğŸª¤ ğŸª’ ğŸ§´ ğŸ§· ğŸ§¹ ğŸ§º ğŸ§» ğŸª£ ğŸ§¼ ğŸ«§ ğŸª¥ ğŸ§½ ğŸ§¯ ğŸ›’ ğŸš¬ âš° ğŸª¦ âš± ğŸ—¿ ğŸª§ ğŸªª ğŸ§ ğŸš® ğŸš° â™¿ ğŸš¹ ğŸšº ğŸš» ğŸš¼ ğŸš¾ ğŸ›‚ ğŸ›ƒ ğŸ›„ ğŸ›… âš  ğŸš¸ â›” ğŸš« ğŸš³ ğŸš­ ğŸš¯ ğŸš± ğŸš· ğŸ“µ ğŸ” â˜¢ â˜£ â¬† â†— â¡ â†˜ â¬‡ â†™ â¬… â†– â†• â†” â†© â†ª â¤´ â¤µ ğŸ”ƒ ğŸ”„ ğŸ”™ ğŸ”š ğŸ”› ğŸ”œ ğŸ” ğŸ› âš› ğŸ•‰ âœ¡ â˜¸ â˜¯ âœ â˜¦ â˜ª â˜® ğŸ• ğŸ”¯ â™ˆ â™‰ â™Š â™‹ â™Œ â™ â™ â™ â™ â™‘ â™’ â™“ â› ğŸ”€ ğŸ” ğŸ”‚ â–¶ â¸ â© â­ â¯ â—€ âª â® ğŸ”¼ â« ğŸ”½ â¬ â¹ âº â ğŸ¦ ğŸ”… ğŸ”† ğŸ“¶ ğŸ“³ ğŸ“´ â™€ â™‚ âš§ âœ– â• â– â— ğŸŸ° â™¾ â€¼ â‰ â“ â” â— â• ã€° ğŸ’± ğŸ’² âš• â™» âšœ ğŸ”± ğŸ“› ğŸ”° â­• âœ… â˜‘ âœ” âŒ â â° â¿ ã€½ âœ³ âœ´ â‡ Â© Â® â„¢ #ï¸âƒ£ *ï¸âƒ£ 0ï¸âƒ£ 1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ 5ï¸âƒ£ 6ï¸âƒ£ 7ï¸âƒ£ 8ï¸âƒ£ 9ï¸âƒ£ ğŸ”Ÿ ğŸ”  ğŸ”¡ ğŸ”¢ ğŸ”£ ğŸ”¤ ğŸ…° ğŸ† ğŸ…± ğŸ…¾ ğŸ†‘ ğŸ†’ ğŸ†“ â„¹ ğŸ†” â“‚ ğŸ†• ğŸ†– ğŸ†— ğŸ…¿ ğŸ†˜ ğŸ†™ ğŸ†š ğŸˆ ğŸˆ‚ ğŸˆ· ğŸˆ¶ ğŸˆ¯ ğŸ‰ ğŸˆ¹ ğŸˆš ğŸˆ² ğŸ‰‘ ğŸˆ¸ ğŸˆ´ ğŸˆ³ ãŠ— ãŠ™ ğŸˆº ğŸˆµ ğŸ”´ ğŸŸ  ğŸŸ¡ ğŸŸ¢ ğŸ”µ ğŸŸ£ ğŸŸ¤ âš« âšª ğŸŸ¥ ğŸŸ§ ğŸŸ¨ ğŸŸ© ğŸŸ¦ ğŸŸª ğŸŸ« â¬› â¬œ ğŸ”¶ ğŸ”· ğŸ”¸ ğŸ”¹ ğŸ”º ğŸ”» ğŸ’  ğŸ”˜ ğŸ”³ ğŸ”² ğŸ ğŸš© ğŸŒ ğŸ´ ğŸ³ ğŸ³ï¸â€ğŸŒˆ ğŸ³ï¸â€âš§ï¸ ğŸ´â€â˜ ï¸

Response Structure:
1. Acknowledge the user's query with understanding
2. Provide clear, structured information
3. Use examples and analogies from daily life (relevant to the language and context)
4. Summarize key points if the response is long
5. End with encouragement or next steps

File Handling:
- When users share images, describe them in detail in your determined response language (default Roman Urdu).
- CRITICAL FOR IMAGES: When an image is shared, your primary task is to describe its visual content. You MUST NOT use the search tool to get information about the image or its contents unless the user EXPLICITLY asks you to search (e.g., 'is image ke baaray mein search karo', 'what is this in the image? search for it').
- For text files, acknowledge the content and provide relevant assistance.
- Suggest ways to better utilize shared files if applicable.

Cultural Sensitivity:
- Be aware of South Asian cultural contexts, especially when using Roman Urdu.
- Use respectful language (e.g., "aap" in Roman Urdu, not "tum") unless the user indicates otherwise.
- Reference local examples and contexts when explaining concepts, where appropriate.
- Be mindful of religious and cultural sensitivities.

Appropriate Discussion Areas:
- Sexual health and wellness
- Physical intimacy and pleasure
- Relationship dynamics and communication
- Dating and romance
- Common sexual concerns
- Safe sex practices
- Body image and confidence
- Emotional intimacy
- Sexual compatibility
- Relationship boundaries
- Personal desires and needs
- Common fantasies
- Consent and boundaries
- Sexual wellness products
- Dating apps and online dating

Language Style (for sensitive topics, adapt to determined language):
- Use appropriate terms for intimate topics.
- Employ medical/clinical terms when needed.
- Use culturally understood euphemisms where appropriate.
- Match user's comfort level with terminology.
- Be direct but tasteful.
- Avoid crude or explicit language.
- Use mature, adult-appropriate phrasing.

Quality Standards:
- Ensure responses are comprehensive yet concise.
- Double-check spelling and grammar for the language used.
- Provide actionable advice whenever possible.
- Follow up complex explanations with "Umeed he apko samjh agyi hogi?" (Roman Urdu) or similar in the response language.
- Encourage questions with "Agar koi sawal ho to zaror poochiye ğŸ˜Š" (Roman Urdu) or similar in the response language.

Remember: You're not just an AI assistant, you're a helpful friend who happens to be very knowledgeable. Make every interaction meaningful and helpful!
`;
      }
      
      const COPY_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`;
      const COPIED_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4"><path d="M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"></path></svg>`;
      const FileTextIcon = (props) => (<i className={`fa-solid fa-file-lines ${props.className || ''}`}></i>);
      const FileImageIcon = (props) => (<i className={`fa-solid fa-file-image ${props.className || ''}`}></i>);

      const NEW_AI_ICON_PATH_D = "M45.403,25.562c-0.506-1.89-1.518-3.553-2.906-4.862c1.134-2.665,0.963-5.724-0.487-8.237	c-1.391-2.408-3.636-4.131-6.322-4.851c-1.891-0.506-3.839-0.462-5.669,0.088C28.276,5.382,25.562,4,22.647,4	c-4.906,0-9.021,3.416-10.116,7.991c-0.01,0.001-0.019-0.003-0.029-0.002c-2.902,0.36-5.404,2.019-6.865,4.549	c-1.391-2.408-1.76,5.214-1.04,7.9c0.507,1.891,1.519,3.556,2.909,4.865c-1.134-2.666-0.97,5.714,0.484,8.234	c1.391,2.408,3.636,4.131,6.322,4.851c0.896,0.24,1.807,0.359,2.711,0.359c1.003,0,1.995-0.161,2.957-0.45	C21.722,44.619,24.425,46,27.353,46c4.911,0,9.028-3.422,10.12-8.003c2.88-0.35,5.431-2.006,6.891-4.535	C45.754,31.054,46.123,28.249,45.403,25.562z M35.17,9.543c2.171,0.581,3.984,1.974,5.107,3.919c1.049,1.817,1.243,4,0.569,5.967	c-0.099-0.062-0.193-0.131-0.294-0.19l-9.169-5.294c-0.312-0.179-0.698-0.177-1.01,0.006l-10.198,6.041l-0.052-4.607l8.663-5.001	C30.733,9.26,33,8.963,35.17,9.543z M29.737,22.195l0.062,5.504l-4.736,2.805l-4.799-2.699l-0.062-5.504l4.736-2.805L29.737,22.195z M14.235,14.412C14.235,9.773,18.009,6,22.647,6c2.109,0,4.092,0.916,5.458,2.488C28,8.544,27.891,8.591,27.787,8.651l-9.17,5.294	c-0.312,0.181-0.504,0.517-0.5,0.877l0.133,11.851l-4.015-2.258V14.412z M6.528,23.921c-0.581-2.17-0.282-4.438,0.841-6.383	c1.06-1.836,2.823-3.074,4.884-3.474c-0.004,0.116-0.018,0.23-0.018,0.348V25c0,0.361,0.195,0.694,0.51,0.872l10.329,5.81	L19.11,34.03l-8.662-5.002C8.502,27.905,7.11,26.092,6.528,23.921z M14.83,40.457c-2.171-0.581-3.984-1.974-5.107-3.919	c-1.053-1.824-1.249-4.001-0.573-5.97c0.101,0.063,0.196,0.133,0.299,0.193l9.169,5.294c0.154,0.089,0.327,0.134,0.5,0.134	c0.177,0,0.353-0.047,0.51-0.14l10.198-6.041l0.052,4.607l-8.663,5.001C19.269,40.741,17.001,41.04,14.83,40.457z M35.765,35.588	c0,4.639-3.773,8.412-8.412,8.412c-2.119,0-4.094-0.919-5.459-2.494c0.105-0.056,0.216-0.098,0.32-0.158l9.17-5.294	c0.312-0.181,0.504,0.517-0.5-0.877L31.75,23.327l4.015,2.258V35.588z M42.631,32.462c-1.056,1.83-2.84,3.086-4.884,3.483	c0.004-0.12,0.018-0.237,0.018-0.357V25c0-0.361-0.195-0.694-0.51-0.872l-10.329-5.81l3.964-2.348l8.662,5.002	c1.946,1.123,3.338,2.937,3.92,5.107C44.053,28.249,43.754,30.517,42.631,32.462z";

      const ReusableNewAiIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" {...props}>
          <defs>
            <linearGradient id="iconGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stopColor="#60a5fa" />
              <stop offset="100%" stopColor="#f472b6" />
            </linearGradient>
          </defs>
          <path fill="url(#iconGradient)" d={NEW_AI_ICON_PATH_D} />
        </svg>
      );

      const ThinkingAnimation = () => (
          <div className="thinking-indicator mt-2.5">
              <ReusableNewAiIcon className="w-5 h-5 animate-spin-continuous" />
              <p>Thinking...</p>
          </div>
      );
      
      const ChatMessageItem = ({ message }) => { 
        const isUser = message.role === 'user'; 
        const isError = message.isError === true; 
        const isModelLoading = message.role === 'model' && message.isLoading && !isError;
        
        const contentRef = useRef(null); 
        const [animatedHtml, setAnimatedHtml] = useState('');
        
        useEffect(() => {
          setAnimatedHtml(marked.parse(message.text || ''));
        }, [message.text]);


        useEffect(() => {
          if (!isModelLoading && contentRef.current) { 
            const preElements = contentRef.current.querySelectorAll('pre');
            preElements.forEach(preEl => {
              if (preEl.parentNode?.classList.contains('code-block-wrapper')) { return; }

              const codeElement = preEl.querySelector('code');
              if (!codeElement) return;

              const wrapper = document.createElement('div');
              wrapper.classList.add('code-block-wrapper', 'relative');

              const button = document.createElement('button');
              button.innerHTML = COPY_ICON_SVG;
              button.className = 'code-copy-button absolute p-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 hover:text-gray-800 border border-gray-300 rounded-md transition-colors duration-150 opacity-80 hover:opacity-100';
              button.style.top = '0.35rem';
              button.style.right = '0.35rem';
              button.style.zIndex = '10';
              button.setAttribute('aria-label', 'Copy code');

              button.onclick = () => { 
                  if (codeElement) {
                    navigator.clipboard.writeText(codeElement.textContent || '')
                      .then(() => {
                        button.innerHTML = COPIED_ICON_SVG;
                        button.classList.add('text-status-success');
                        setTimeout(() => {
                          button.innerHTML = COPY_ICON_SVG;
                          button.classList.remove('text-status-success');
                        }, 2000);
                      })
                      .catch(err => console.error('Failed to copy code: ', err));
                  }
              };

              if (preEl.parentNode) {
                preEl.parentNode.insertBefore(wrapper, preEl);
                wrapper.appendChild(preEl); 
                wrapper.appendChild(button); 
              }
              
              if (!codeElement.dataset.highlighted) {
                hljs.highlightElement(codeElement);
                codeElement.dataset.highlighted = 'true';
              }
            });
            
            const links = contentRef.current.querySelectorAll('.markdown-content a');
            links.forEach(link => {
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
            });
          }
        }, [animatedHtml, isModelLoading]); 

        if (message.role === 'system') { const systemMessageStyle = isError ? "px-4 py-2 text-xs text-red-700 bg-red-100 border border-red-300 rounded-full shadow-sm italic" : "px-4 py-2 text-xs text-text-subtle bg-surface-accent border border-border-light rounded-full shadow-sm italic"; return (<div className="flex justify-center my-4 animate-fade-in-up opacity-0" style={{animationFillMode: 'forwards'}}><div className={systemMessageStyle}>{isError ? <><i className="fas fa-exclamation-triangle mr-1.5"></i> {message.text}</> : message.text }</div></div>);}
        
        let bubbleBaseClasses = 'px-4 py-3 md:px-4 md:py-3 shadow-card animate-fade-in-up opacity-0'; 
        let bubbleRoleClasses = ''; 
        let bubbleWidthClasses = ''; 
        let contentToShow = null;
        
        if (isUser) { 
          bubbleRoleClasses = 'bg-white text-text-primary rounded-t-2xl rounded-bl-2xl rounded-br-md border border-[#E5E8EB] text-sm'; 
          bubbleWidthClasses = 'max-w-[80%] sm:max-w-[75%]'; 
          contentToShow = <p className="whitespace-pre-wrap break-words">{message.text}</p>;
        } else if (message.role === 'model') { 
            bubbleWidthClasses = 'max-w-full w-full'; 
            
            if(isError) { 
                bubbleRoleClasses = 'bg-red-50 border border-red-300 text-red-700 rounded-2xl text-sm';
                contentToShow = ( <div className="break-words"> <div className="flex items-center mb-1"><i className="fas fa-exclamation-triangle text-red-500 mr-2"></i><strong className="font-semibold">Error</strong></div>{message.text.replace(/^Error:\s*/, '')} </div>); 
            } else { 
                // For normal AI responses, remove the card/bubble styling to make it appear directly on the chat area
                bubbleBaseClasses = 'animate-fade-in-up opacity-0'; // Remove padding and shadow
                bubbleRoleClasses = 'text-text-primary text-sm'; // Remove background, border, and rounding

                // The content remains the same
                contentToShow = (
                  <div ref={contentRef}>
                    <div className="markdown-content break-words" dangerouslySetInnerHTML={{ __html: animatedHtml }} />
                  </div>
                );
            } 
        }

        return (
          <div className={`flex items-end ${isUser ? 'justify-end' : 'justify-start'} animate-fade-in-up opacity-0`} style={{animationFillMode: 'forwards'}}>
            <div className={`${bubbleBaseClasses} ${bubbleWidthClasses} ${bubbleRoleClasses}`} style={{animationFillMode: 'forwards'}}>
              {isUser && message.attachedFiles && message.attachedFiles.length > 0 && (
                <div className={`grid gap-2.5 ${message.text ? 'mb-2.5' : ''} ${message.attachedFiles.length > 1 ? 'grid-cols-2' : 'grid-cols-1'}`}>
                  {message.attachedFiles.map(file => {
                    if (file.type?.startsWith('image/') && file.apiData?.data && file.apiData?.mimeType) {
                      const imageSrc = `data:${file.apiData.mimeType};base64,${file.apiData.data}`;
                      return (
                        <div key={file.id || file.name} className="rounded-lg overflow-hidden border border-brand-primary/20 bg-brand-primary/10 shadow-sm group relative max-w-full w-full sm:w-auto sm:max-w-[180px]">
                          <img src={imageSrc} alt={file.name || 'image preview'} className="block w-full max-h-40 object-contain" />
                          <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center p-1">
                            <p className="text-[10px] text-white text-center truncate font-medium">{file.name}</p>
                          </div>
                        </div>
                      );
                    } else {
                      return (
                        <div key={file.id || file.name} className="bg-brand-primary/10 border border-brand-primary/20 p-2.5 rounded-lg text-xs flex items-center space-x-2 max-w-full w-fit shadow">
                          {file.type?.startsWith('image/') ? 
                            <FileImageIcon className="text-brand-primary text-base" /> : 
                            <FileTextIcon className="text-brand-primary text-base" />
                          }
                          <span className="truncate max-w-[120px] sm:max-w-[150px] text-text-primary font-medium">
                            {file.name}{file.type?.startsWith('image/') ? " (preview unavailable)" : ""}
                          </span>
                        </div>
                      );
                    }
                  })}
                </div>
              )}
              {contentToShow} 
              {isModelLoading && !message.text && <ThinkingAnimation />} 
            </div>
          </div>);
      };
      
      const ChatInterface = ({ messages, onSendMessage, isLoading, onStopGeneration, onRegenerateLastTextMessage, onClearChat, setChatError }) => {
        const [inputText, setInputText] = useState(''); const [selectedFiles, setSelectedFiles] = useState([]); const [isMobileView, setIsMobileView] = useState(false); const [userHasScrolledUp, setUserHasScrolledUp] = useState(false);
        const fileInputRef = useRef(null); const messagesEndRef = useRef(null); const chatContainerRef = useRef(null); 
        const contentEditableRef = useRef(null);

        useEffect(() => { const checkMobileView = () => setIsMobileView(window.innerWidth < 768); window.addEventListener('resize', checkMobileView); checkMobileView(); return () => window.removeEventListener('resize', checkMobileView); }, []);
        useEffect(() => { const container = chatContainerRef.current; if (!container) return; const handleScroll = () => { const { scrollTop, scrollHeight, clientHeight } = container; setUserHasScrolledUp(scrollHeight - scrollTop - clientHeight >= 20);}; container.addEventListener('scroll', handleScroll, { passive: true }); return () => container.removeEventListener('scroll', handleScroll); }, []); 
        
        useEffect(() => {
          const lastMessage = messages[messages.length - 1];
          if (!lastMessage) return; 

          const messagesEndEl = messagesEndRef.current;
          if (!messagesEndEl) return;

          if (lastMessage.role === 'user') {
            messagesEndEl.scrollIntoView({ behavior: "smooth" });
          } else if (lastMessage.role === 'model') {
            if (!userHasScrolledUp) { 
              if (lastMessage.isLoading) {
                messagesEndEl.scrollIntoView({ behavior: "auto", block: "end" }); 
              } else {
                messagesEndEl.scrollIntoView({ behavior: "smooth" });
              }
            }
          }
        }, [messages, userHasScrolledUp]);

        const handleFileChange = async (event) => { const files = Array.from(event.target.files); processAndSetFiles(files); if (fileInputRef.current) fileInputRef.current.value = ""; };
        const handlePaste = async (event) => { 
            const pastedFiles = Array.from(event.clipboardData.files); 
            if (pastedFiles.length > 0) { 
                const processedSomething = await processAndSetFiles(pastedFiles, true); 
            }
        };
        const processAndSetFiles = async (filesArray, isFromPaste = false) => { if (!filesArray.length) return false; let filesToProcess = []; let currentTotalSize = selectedFiles.reduce((acc, curr) => acc + (curr.file?.size || 0), 0); let didProcessAnyFile = false; let localErrorMessage = null; for (const file of filesArray) { const isImage = file.type.startsWith('image/'); const isTxt = file.type === 'text/plain' || (file.name && file.name.toLowerCase().endsWith('.txt')); if (!isImage && !isTxt) { if (isFromPaste) console.log(`Pasted unsupported file: ${file.name} (${file.type})`); else localErrorMessage = `File "${file.name}" (type: ${file.type}) is not supported. Only images and .txt files allowed.`; continue; } if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) { localErrorMessage = `File "${file.name}" is larger than ${MAX_FILE_SIZE_MB}MB.`; continue; } if (currentTotalSize + file.size > MAX_TOTAL_FILES_SIZE_MB * 1024 * 1024) { localErrorMessage = `Total file size cannot exceed ${MAX_TOTAL_FILES_SIZE_MB}MB.`; break; } filesToProcess.push(file); currentTotalSize += file.size; didProcessAnyFile = true; } if(localErrorMessage){ setChatError(localErrorMessage); } else { setChatError(null); } if (filesToProcess.length > 0) { const processedFileObjects = await Promise.all( filesToProcess.map(async (file) => { const id = Date.now().toString(36) + Math.random().toString(36).substring(2) + file.name; let apiData; if (file.type.startsWith('image/')) { const base64Data = await new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onloadend = () => resolve(reader.result.split(',')[1]); reader.onerror = (error) => reject(error); }); apiData = { mimeType: file.type, data: base64Data }; } else { const textContent = await file.text(); apiData = { textContent: textContent }; } return { id, file, name: file.name, type: file.type, apiData }; }) ); setSelectedFiles(prev => [...prev, ...processedFileObjects.filter(f => f)]); } return didProcessAnyFile; };
        const removeSelectedFile = (fileId) => { setSelectedFiles(prev => prev.filter(f => f.id !== fileId)); };
        
        const handleSubmit = (e) => { 
            if(e) e.preventDefault(); 
            const trimmedInput = inputText.trim(); 
            if (!trimmedInput && selectedFiles.length === 0) return; 
            
            setUserHasScrolledUp(false); 
            setChatError(null); 
            onSendMessage(trimmedInput, selectedFiles); 
            setInputText(''); 
            if (contentEditableRef.current) {
                contentEditableRef.current.innerHTML = ''; 
            }
            setSelectedFiles([]); 
        };

        const handleInputFromContentEditable = (e) => {
            let currentText = e.currentTarget.innerText;
            if (currentText === '\n' && e.currentTarget.innerHTML === '<br>') {
                 currentText = '';
                 e.currentTarget.innerHTML = '';
            }
            setInputText(currentText);
        };
        
        const handleContentEditableKeyDown = (e) => {
            if (!isMobileView && e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!isSendButtonDisabled) {
                    handleSubmit(e);
                }
            }
        };

        const isAiCurrentlyProcessing = messages.some(m => m.role === 'model' && m.isLoading && !m.isError);
        const isSendButtonDisabled = (!isAiCurrentlyProcessing && (isLoading || (inputText.trim() === '' && selectedFiles.length === 0)));
        
        const hasVisibleChatContent = messages.some( msg => (msg.text || msg.attachedFiles?.length > 0) && !(msg.role === 'system' && !msg.isError) );

        const lastMessage = messages[messages.length - 1];
        const userMessageForLastAi = messages.length > 1 ? messages[messages.length - 2] : null;

        const isLastMessageAiAndFinalized = lastMessage && lastMessage.role === 'model' && !lastMessage.isLoading && !isAiCurrentlyProcessing;
        const canRegenerateLastAiAsText = isLastMessageAiAndFinalized && userMessageForLastAi && userMessageForLastAi.role === 'user';

        const sendOrStopButtonBaseClasses = "font-semibold w-9 h-9 rounded-full flex items-center justify-center transition-colors duration-150 ease-in-out transform active:animate-button-press flex-shrink-0 focus:outline-none";
        let sendOrStopButtonDynamicClasses = "bg-slate-200 hover:bg-slate-300 text-text-button-icon"; 

        if (isAiCurrentlyProcessing) { 
        } else { 
            if (isSendButtonDisabled) {
              sendOrStopButtonDynamicClasses = 'bg-slate-200 text-slate-400 cursor-not-allowed';
            } else {
                 sendOrStopButtonDynamicClasses += ' focus:ring-2 focus:ring-focus-ring-color'; 
            }
        }


        return (
          <div className="w-full h-full sm:max-w-2xl md:max-w-3xl lg:max-w-[780px] sm:mx-auto bg-white rounded-none sm:rounded-xl shadow-chat-window flex flex-col overflow-hidden sm:my-6 sm:max-h-[calc(100vh-3rem)]">
            <header className="p-4 bg-white border-b border-border-default flex items-center justify-between flex-shrink-0">
                <div className="flex items-center space-x-2">
                    <ReusableNewAiIcon className="w-8 h-8" />
                    <div>
                        <h1 className="text-lg font-roboto font-semibold tracking-tight text-gradient-brand">AlphaGPT</h1>
                    </div>
                </div>
                <button onClick={() => { setChatError(null); onClearChat(); }} className="text-sm font-medium text-text-secondary hover:text-text-primary px-3 py-1.5 rounded-lg hover:bg-gray-100 transition-colors duration-150 disabled:opacity-50 flex items-center space-x-1.5 group" aria-label="Clear chat" disabled={isLoading || messages.filter(m=>m.text || m.attachedFiles?.length > 0).length === 0}><i className="fas fa-broom fa-fw text-sm transition-transform group-hover:scale-110"></i><span className="hidden sm:inline">Clear</span></button>
            </header>
            
            <div ref={chatContainerRef} className="flex-grow p-4 md:p-5 space-y-4 md:space-y-5 overflow-y-auto chat-messages-container relative bg-surface-chat-area">
                { !hasVisibleChatContent && !isLoading && ( 
                    <div className="absolute inset-0 flex flex-col items-center justify-center text-center pointer-events-none p-8 opacity-0 animate-fade-in-up" style={{animationDelay: '0.2s', animationFillMode: 'forwards'}}>
                        <p className="text-xl md:text-2xl font-[Outfit] font-semibold mb-2" style={{ color: '#536872' }}>Hello there!</p>
                        <p className="text-sm font-[Outfit] mt-1.5" style={{ color: '#536872' }}>I am AlphaGPT. You can ask me anything or share files to get started.</p>
                    </div> 
                )}
                {messages.map((msg) => ( (msg.text || msg.attachedFiles?.length > 0 || (msg.role === 'model' && msg.isLoading) || msg.isError) && 
                    <div key={msg.id}> 
                        <ChatMessageItem message={msg} /> 
                    </div> 
                ))}
                {canRegenerateLastAiAsText && (
                    <div className={`flex mt-2 justify-start`}> 
                        <button 
                            onClick={() => { 
                                setChatError(null); 
                                onRegenerateLastTextMessage(lastMessage.id);
                            }} 
                            className="p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover transition-all duration-150 group" 
                            aria-label="Regenerate response" 
                            disabled={isLoading || isAiCurrentlyProcessing} 
                        > 
                            <i className="fas fa-arrows-rotate text-xs transform transition-transform duration-200 group-hover:rotate-[75deg]"></i> 
                        </button> 
                    </div> 
                )}
                <div ref={messagesEndRef} className="h-1" />
            </div>
            
            <form onSubmit={handleSubmit} className="bg-surface-chat-area flex-shrink-0">
              <div className="p-2 md:p-3"> 
                <div 
                    className="flex flex-col bg-white border border-border-medium rounded-2xl p-2 shadow-sm" 
                    style={{ minHeight: '60px' }}
                    onClick={(e) => { 
                        if (contentEditableRef.current && !contentEditableRef.current.contains(e.target) && e.target.tagName !== 'BUTTON' && !e.target.closest('button')) {
                           contentEditableRef.current.focus();
                        }
                    }}
                >
                  {selectedFiles.length > 0 && (
                    <div className="file-pill-container"> 
                        {selectedFiles.map(file => ( 
                            <div key={file.id} className="file-pill"> 
                                {file.type.startsWith('image/') ? <FileImageIcon className="file-pill-icon"/> : <FileTextIcon className="file-pill-icon"/> } 
                                <span className="file-pill-name">{file.name}</span> 
                                <button type="button" onClick={() => removeSelectedFile(file.id)} className="file-pill-remove"> 
                                    <i className="fas fa-times"></i> 
                                </button> 
                            </div>
                        ))}
                    </div>
                  )}

                  <div
                    ref={contentEditableRef}
                    contentEditable={!(isLoading || isAiCurrentlyProcessing)}
                    onInput={handleInputFromContentEditable}
                    onPaste={handlePaste}
                    onKeyDown={handleContentEditableKeyDown}
                    data-placeholder="Ask AlphaGPT..." 
                    className="content-editable-input w-full flex-1 text-sm md:text-base focus:outline-none resize-none overflow-y-auto relative" 
                    style={{ maxHeight: selectedFiles.length > 0 ? '80px' : '100px', minHeight: '24px' }} 
                    suppressContentEditableWarning={true}
                  >
                  </div>

                  <div className="flex justify-between items-center w-full pt-1.5 mt-auto">
                    <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" multiple accept="image/*,.txt,text/plain" disabled={isLoading || isAiCurrentlyProcessing} />
                    <button
                      type="button"
                      onClick={() => fileInputRef.current?.click()}
                      className="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-brand-primary transition-colors duration-150 disabled:opacity-60 flex-shrink-0 rounded-full hover:bg-gray-200 focus:outline-none"
                      aria-label="Attach file"
                      disabled={isLoading || isAiCurrentlyProcessing}
                    >
                      <i className="fas fa-plus text-lg"></i>
                    </button>

                    <button 
                        type={isAiCurrentlyProcessing ? "button" : "submit"} 
                        onClick={isAiCurrentlyProcessing ? onStopGeneration : undefined } 
                        disabled={isSendButtonDisabled} 
                        className={`${sendOrStopButtonBaseClasses} ${sendOrStopButtonDynamicClasses}`}
                        style={{ overflow: 'hidden' }}
                        aria-label={isAiCurrentlyProcessing ? "Stop generation" : "Send message"}
                    > 
                      {isAiCurrentlyProcessing ? (
                        <i className="fas fa-stop text-sm"></i> 
                      ) : (
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-4 h-4"> 
                          <path d="M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z" />
                        </svg>
                      )} 
                    </button> 
                  </div>
                </div>
              </div>
            </form>
          </div>);
      };
      
      const App = () => { 
        const [chatMessages, setChatMessages] = useState([]); 
        const [isChatLoading, setIsChatLoading] = useState(false); 
        const [chatError, setChatError] = useState(null); 

        const isStoppingGenerationRef = useRef(false);
        const streamTextBuffer = useRef(""); 

        useEffect(() => { 
            if (chatError) { 
                const errorId = Date.now() + '_sys_validation_err'; 
                setChatMessages(prev => { 
                    const lastMessage = prev[prev.length -1]; 
                    if(lastMessage && lastMessage.id.includes('_sys_validation_err') && lastMessage.text === chatError) return prev; 
                    return [...prev, {id: errorId, role: 'system', text: chatError, isError: true, timestamp: new Date()}]; 
                }); 
            }
        }, [chatError]); 

        const getGeminiHistory = (currentMessagesInternalFormat) => {
            const geminiMessages = currentMessagesInternalFormat
                .filter(msg => !(msg.role === 'system' || (msg.role === 'model' && msg.isLoading) || msg.isError))
                .map(msg => {
                    const parts = [];
                    if (msg.role === 'model') {
                        if (msg.text) { 
                            parts.push({ text: msg.text });
                        }
                    } else if (msg.role === 'user') {
                        const trimmedUserText = msg.text ? msg.text.trim() : "";
                        if (trimmedUserText) parts.push({ text: trimmedUserText });
                        
                        if (msg.attachedFiles) {
                            msg.attachedFiles.forEach(file => {
                                if (file.type.startsWith('image/') && file.apiData?.mimeType && file.apiData?.data) {
                                    parts.push({ inlineData: { mimeType: file.apiData.mimeType, data: file.apiData.data } });
                                } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent) {
                                    parts.push({ text: `\n[Attached Text File: ${file.name}]\n${file.apiData.textContent}\n` });
                                }
                            });
                        }
                    }
                    return { role: msg.role, parts };
                }).filter(entry => entry.parts.length > 0);

            if (geminiMessages.length > 0 && geminiMessages[0].role === 'model') {
                const firstUserIndex = geminiMessages.findIndex(m => m.role === 'user');
                if (firstUserIndex === -1) return []; 
                const slicedHistory = geminiMessages.slice(firstUserIndex);
                if (slicedHistory.length > 1 && slicedHistory[0].role === slicedHistory[1].role) {
                    return [slicedHistory[0]];
                }
                return slicedHistory;
            }
            return geminiMessages;
        };
        useEffect(() => { if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") { setChatError("API Key is not configured. Please set it up."); } }, []); 
        
        const handleStopGeneration = useCallback(() => {
            isStoppingGenerationRef.current = true;
            setIsChatLoading(false); 

            setChatMessages(prevMessages => {
                let messageUpdated = false;
                const updatedMessages = prevMessages.map(msg => {
                    if (msg.role === 'model' && msg.isLoading) {
                        messageUpdated = true;
                        let newText = streamTextBuffer.current || msg.text || ""; 
                        const stopNotice = "*Generation stopped by user.*";
                        
                        if (!newText.includes(stopNotice)) {
                            const currentContent = newText;
                            if (currentContent.trim()) {
                                let processedContent = currentContent;
                                const isInCodeBlock = (processedContent.match(/```/g) || []).length % 2 !== 0;
                                if (isInCodeBlock) {
                                    processedContent += "\n```"; 
                                }
                                newText = processedContent + (processedContent.trim() ? "\n\n---\n" : "") + stopNotice;
                            } else {
                                newText = stopNotice;
                            }
                        }
                        return { ...msg, text: newText, isLoading: false };
                    }
                    return msg;
                });
                return messageUpdated ? updatedMessages : prevMessages;
            });
        }, []); 

        const handleClearChat = useCallback(() => { if(!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY"){ setChatError("API Key is not configured. Please set it up to use the chat."); } else { setChatError(null); } setChatMessages([]); }, []);
        
        const _streamAiResponse = async (
            originalPromptParts, 
            targetAiMessageId, 
            historyForGeminiInit
        ) => {
            setIsChatLoading(true);
            isStoppingGenerationRef.current = false;
            
            let displayedAiText = ""; 
            streamTextBuffer.current = ""; 

            try {
                const modelConfig = { 
                    model: GEMINI_MAIN_MODEL, 
                    systemInstruction: getSystemInstruction(),
                    tools: [{ googleSearch: {} }] 
                };
                const chatModel = genAI.getGenerativeModel(modelConfig);
                const chatSession = chatModel.startChat({ history: historyForGeminiInit });
                
                if (isStoppingGenerationRef.current) {
                     setIsChatLoading(false);
                     return;
                }

                const result = await chatSession.sendMessageStream(originalPromptParts);

                for await (const chunk of result.stream) { 
                    if (isStoppingGenerationRef.current) break;
                    
                    const rawChunkText = chunk.text();
                    let chunkContentForDisplay = "";

                    if (typeof rawChunkText === 'string') {
                        const lines = rawChunkText.split('\n');
                        const filteredLines = lines.filter(line => 
                            !line.trim().startsWith("tool_code") &&
                            !line.trim().startsWith("print(google_search.search")
                        );
                        if (filteredLines.length > 0 && filteredLines.some(line => line.trim() !== "" || lines.length === filteredLines.length )) {
                           chunkContentForDisplay = filteredLines.join('\n');
                        } else if (filteredLines.length === 0 && rawChunkText.trim() !== "") {
                            chunkContentForDisplay = ""; 
                        } else {
                            chunkContentForDisplay = rawChunkText; 
                        }
                    }

                    if (chunkContentForDisplay.length > 0 || (chunkContentForDisplay === "" && rawChunkText === "")) { 
                        const textParts = chunkContentForDisplay.split(/(\s+|\*+|`+|_|~|---|===|\n)/); 
                        for (const part of textParts) {
                            if (isStoppingGenerationRef.current) break;
                            if (part.length === 0) continue;

                            displayedAiText += part;
                            streamTextBuffer.current = displayedAiText; 

                            setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { 
                                ...m, 
                                text: displayedAiText, 
                                isLoading: true, 
                                isError: false,
                            } : m));
                            
                            await new Promise(resolve => setTimeout(resolve, 5 + part.length * 1)); 
                        }
                    }
                    if (isStoppingGenerationRef.current) break;
                }
                
                setChatMessages(prev => prev.map(m => {
                    if (m.id === targetAiMessageId) {
                        let finalText = streamTextBuffer.current;
                        let isMessageError = false; 
                        const stopNoticeStr = "*Generation stopped by user.*";

                        if (isStoppingGenerationRef.current) { 
                            let baseText = streamTextBuffer.current;
                            if (!baseText.includes(stopNoticeStr)) {
                                const isInCodeBlock = (baseText.match(/```/g) || []).length % 2 !== 0;
                                if (isInCodeBlock) baseText += "\n```";
                                baseText += (baseText.trim() ? "\n\n---\n" : "") + stopNoticeStr;
                            }
                            finalText = baseText;
                        } else if (!finalText.trim() && !isStoppingGenerationRef.current) {
                            finalText = "Mujhe samajhne mein kuch dushwari hui ya abhi iska jawab nahi mil pa raha. Kya aap apna sawal wazeh kar sakte hain ya dobara pooch sakte hain? ğŸ¤”";
                        }
                        return { 
                            ...m, 
                            text: finalText, 
                            isLoading: false, 
                            isError: isMessageError, 
                        };
                    }
                    return m;
                }));

            } catch (err) {
                console.error("AI stream error in _streamAiResponse:", err);
                let errorTextForUser = "Jawab dene mein kuch takneeki dushwari pesh aa rahi hai. Barah-e-karam thori dair baad dobara koshish karein."; 
                if (err.message?.toLowerCase().includes("api key not valid")) errorTextForUser = "Lagta hai API key mein koi masla hai.";
                else if (err.message?.toLowerCase().includes("candidate was blocked")) errorTextForUser = "Meri hifazati policies ki wajah se main yeh jawab nahi de sakta.";
                else if (err.message?.toLowerCase().includes("quota")) errorTextForUser = "API istemal ki had poori ho gayi hai.";
                
                setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { ...m, role: 'model', text: errorTextForUser, isLoading: false, isError: true } : m));
            } finally {
                setIsChatLoading(false);
                 if (isStoppingGenerationRef.current) { 
                    setChatMessages(prev => prev.map(m => (m.id === targetAiMessageId && m.isLoading) ? {...m, isLoading: false} : m ));
                }
            }
        };

        const handleSendChatMessage = useCallback(async (rawMessageText, filesToSend) => {
            const messageText = rawMessageText.trim(); 
            if (!messageText && filesToSend.length === 0) return;

            isStoppingGenerationRef.current = false; 
            setChatError(null);
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") {
                setChatError("API Key is not configured.");
                return;
            }
            
            const currentChatHistoryForGemini = getGeminiHistory(chatMessages);
            const userMessageFiles = filesToSend.map(f => ({ id: f.id, name: f.name, type: f.type, apiData: f.apiData }));
            
            const newUserMessageForUi = { id: Date.now().toString() + '_user', role: 'user', text: messageText, timestamp: new Date(), attachedFiles: userMessageFiles };
            const aiMessageId = Date.now().toString() + '_model_resp';

            const preliminaryAiPlaceholder = { 
                id: aiMessageId, 
                role: 'model', 
                text: '', 
                timestamp: new Date(), 
                isLoading: true, 
                isError: false, 
            }; 
            
            setChatMessages(prev => {
                const filteredPrev = prev.filter(m => !(m.role === 'system' && m.isError));
                return [...filteredPrev, newUserMessageForUi, preliminaryAiPlaceholder];
            });
            
            const promptPartsForUserTurn = [];
            if (messageText) promptPartsForUserTurn.push({ text: messageText }); 
            filesToSend.forEach(file => {
                if (file.type.startsWith('image/') && file.apiData.mimeType && file.apiData.data) {
                    promptPartsForUserTurn.push({ inlineData: file.apiData });
                } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData.textContent) {
                    promptPartsForUserTurn.push({ text: `\n[Start of Text File: ${file.name}]\n${file.apiData.textContent}\n[End of Text File: ${file.name}]\n` });
                }
            });

            if (promptPartsForUserTurn.length > 0) {
                await _streamAiResponse(
                    promptPartsForUserTurn, 
                    aiMessageId, 
                    currentChatHistoryForGemini
                );
            } else { 
                setChatMessages(prev => prev.map(m => m.id === aiMessageId ? { ...m, role: 'model', text: "No content to send.", isLoading: false, isError: true } : m ).filter(msg => msg.id !== aiMessageId || msg.isError));
                setIsChatLoading(false);
            }
            
        }, [chatMessages]); 

        const handleRegenerateLastTextMessage = useCallback(async (aiMessageIdToRegenerate) => { 
            isStoppingGenerationRef.current = false; 
            setChatError(null);
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") {
                setChatError("API Key is not configured for regeneration.");
                return;
            }
            const originalAiMsgIndex = chatMessages.findIndex(m => m.id === aiMessageIdToRegenerate);
            if (originalAiMsgIndex <= 0 || chatMessages[originalAiMsgIndex-1].role !== 'user') {
                setChatError("Cannot regenerate: Preceding user prompt not found.");
                return;
            }
            
            const userPromptMsg = chatMessages[originalAiMsgIndex-1];
            const userPromptTextForRegen = userPromptMsg.text || ""; 

            const historyBeforeUserPromptInternal = chatMessages.slice(0, originalAiMsgIndex - 1);
            const historyForGeminiInit = getGeminiHistory(historyBeforeUserPromptInternal);

            const newAiPlaceholderId = Date.now().toString() + '_model_regen'; 
            
            const preliminaryAiPlaceholder = { 
                id: newAiPlaceholderId, 
                role: 'model', 
                text:'', 
                isLoading:true, 
                timestamp:new Date(), 
                isError: false, 
            };
            
            const chatHistoryForUiUpdate = chatMessages.slice(0, originalAiMsgIndex);
            setChatMessages([...chatHistoryForUiUpdate, preliminaryAiPlaceholder]);
            
            const promptPartsForRegen = [];
            if (userPromptTextForRegen) promptPartsForRegen.push({ text: userPromptTextForRegen });
            userPromptMsg.attachedFiles?.forEach(file => { 
                 if (file.type.startsWith('image/') && file.apiData.mimeType && file.apiData.data) {
                    promptPartsForRegen.push({ inlineData: file.apiData });
                 } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent) {
                    promptPartsForRegen.push({ text: `\n[Start of Text File: ${file.name}]\n${file.apiData.textContent}\n[End of Text File: ${file.name}]\n` });
                }
            });

            if (promptPartsForRegen.length > 0) {
                await _streamAiResponse(
                    promptPartsForRegen, 
                    newAiPlaceholderId, 
                    historyForGeminiInit
                );
            } else { 
                setChatMessages(prev => prev.map(m => m.id === newAiPlaceholderId ? {...m, isLoading: false, text: "No content found to regenerate.", isError: true} : m));
            }
        }, [chatMessages]); 


        return (
            <div className="h-full text-text-primary flex flex-col font-sans items-center justify-start sm:justify-center p-0">
                <ChatInterface 
                    messages={chatMessages} 
                    onSendMessage={handleSendChatMessage} 
                    isLoading={isChatLoading} 
                    onStopGeneration={handleStopGeneration} 
                    onRegenerateLastTextMessage={handleRegenerateLastTextMessage} 
                    onClearChat={handleClearChat} 
                    setChatError={setChatError} 
                />
            </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>
