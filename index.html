<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AlphaGPT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': 'rgb(var(--brand-primary) / <alpha-value>)',      
              'brand-secondary': 'rgb(var(--brand-secondary) / <alpha-value>)',  
              'surface-main': 'rgb(var(--surface-main) / <alpha-value>)',       
              'surface-card': 'rgb(var(--surface-card) / <alpha-value>)',      
              'surface-input': 'rgb(var(--surface-input) / <alpha-value>)',    
              'surface-accent': 'rgb(var(--surface-accent) / <alpha-value>)',    
              'surface-bubble-ai': 'rgb(var(--surface-bubble-ai) / <alpha-value>)',
              'surface-chat-area': 'rgb(var(--surface-chat-area) / <alpha-value>)', 
              'surface-user-bubble-bg': 'rgb(var(--surface-user-bubble-bg-val) / <alpha-value>)', 
              'border-user-bubble-color': 'rgb(var(--border-user-bubble-color-val) / <alpha-value>)',

              'text-primary': 'rgb(var(--text-primary) / <alpha-value>)',         
              'text-secondary': 'rgb(var(--text-secondary) / <alpha-value>)',           
              'text-on-primary': 'rgb(var(--text-on-primary) / <alpha-value>)',
              'text-subtle': 'rgb(var(--text-subtle) / <alpha-value>)',
              'text-button-icon': 'rgb(var(--text-button-icon) / <alpha-value>)',
              'link-blue': '#0000FF', 
              'link-blue-hover': '#0000CC', 


              'border-default': 'rgb(var(--border-default) / <alpha-value>)',
              'border-light': 'rgb(var(--border-light) / <alpha-value>)',
              'border-medium': 'rgb(var(--border-medium) / <alpha-value>)',
              'interactive-hover': 'rgb(var(--interactive-hover) / <alpha-value>)',
              'focus-ring-color': 'rgb(var(--focus-ring-color) / <alpha-value>)',
              
              'status-info': 'rgb(var(--status-info) / <alpha-value>)',
              'status-success': 'rgb(var(--status-success) / <alpha-value>)',
              'status-warning': 'rgb(var(--status-warning) / <alpha-value>)',
              'status-error': 'rgb(var(--status-error) / <alpha-value>)',
              'error-fg': 'rgb(var(--error-fg) / <alpha-value>)', 
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              poppins: ['Poppins', 'sans-serif'],
              roboto: ['Roboto', 'sans-serif'],
            },
            animation: {
              'fade-in-up': 'fadeInUp 0.5s ease-out forwards',
              'scale-in-subtle': 'scaleInSubtle 0.35s ease-out forwards',
              'pulse-gentle': 'pulseGentle 2.8s infinite ease-in-out', 
              'button-press': 'buttonPress 0.2s ease-out',
              'rippleOut': 'rippleOut 2.5s infinite ease-out', 
              'speak-bob': 'speakBob 0.7s ease-in-out',
              'think-glance': 'thinkGlance 2s infinite ease-in-out',
              'blink': 'blink 4s infinite ease-in-out',
              'happy-bounce': 'happyBounce 0.5s ease-out',
              'empty-state-glow': 'emptyStateGlow 3.5s infinite alternate ease-in-out',
              'shiny-text': 'shinyText 2.5s linear infinite',
              'modal-fade-in': 'modal-fade-in 0.3s ease-out forwards', 
              'modal-fade-out': 'modal-fade-out 0.3s ease-in forwards',
              'shimmer': 'shimmer 1.5s ease-in-out infinite',
              'spin-continuous': 'spinContinuous 2s linear infinite',
            },
            keyframes: {
              fadeInUp: { '0%': { opacity: '0', transform: 'translateY(10px)' }, '100%': { opacity: '1', transform: 'translateY(0)' }, },
              scaleInSubtle: { '0%': { opacity: '0.5', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' }, },
              pulseGentle: {  '0%, 100%': { transform: 'scale(1)', opacity: '0.8' }, '50%': { transform: 'scale(1.015)', opacity: '1' }, },
              buttonPress: { '0%': { transform: 'scale(1)' }, '50%': { transform: 'scale(0.96)'}, '100%': { transform: 'scale(1)' }, },
              emptyStateGlow: {  '0%': { filter: 'drop-shadow(0 0 3px rgba(var(--brand-primary), 0.2)) drop-shadow(0 0 6px rgba(var(--brand-primary), 0.15))' }, '100%': { filter: 'drop-shadow(0 0 6px rgba(var(--brand-primary), 0.25)) drop-shadow(0 0 12px rgba(var(--brand-primary), 0.18))' }, },
              rippleOut: {  '0%': { transform: 'scale(0.8)', opacity: '0.3' }, '70%': { opacity: '0.1' }, '100%': { transform: 'scale(2.0)', opacity: '0' }, },
              speakBob: { '0%, 100%': { transform: 'translateY(0) scale(1)' }, '50%': { transform: 'translateY(-2px) scale(1.05)' }, },
              thinkGlance: { '0%, 100%': { transform: 'translateX(0px)' }, '25%': { transform: 'translateX(-1px)' }, '75%': { transform: 'translateX(1px)' }, },
              blink: { '0%, 90%, 100%': { transform: 'scaleY(1)' }, '95%': { transform: 'scaleY(0.1)' }, },
              happyBounce: { '0%, 100%': { transform: 'translateY(0) rotate(0deg) scale(1)' }, '50%': { transform: 'translateY(-3px) rotate(3deg) scale(1.03)' }, },
              shinyText: { '0%': { backgroundPosition: '-200% center' }, '100%': { backgroundPosition: '200% center' }, },
              'modal-fade-in': { 
                '0%': { opacity: '0', transform: 'scale(0.95)' },
                '100%': { opacity: '1', transform: 'scale(1)' },
              },
              'modal-fade-out': { 
                '0%': { opacity: '1', transform: 'scale(1)' },
                '100%': { opacity: '0', transform: 'scale(0.95)' },
              },
              shimmer: {
                '0%': { transform: 'translateX(-100%)' },
                '100%': { transform: 'translateX(100%)' },
              },
              spinContinuous: { 
                '0%': { transform: 'rotate(0deg)' },
                '100%': { transform: 'rotate(360deg)' }
              },
            },
            spacing: { 
              '1.5': '0.375rem', 
              '2.5': '0.625rem',
            },
            boxShadow: {
                'card': '0 6px 20px rgba(var(--text-primary), 0.04), 0 3px 8px rgba(var(--text-primary),0.02)', 
                'header': '0 1px 2px rgba(var(--text-primary), 0.03), 0 1px 1px rgba(var(--text-primary), 0.015)',
                'input-focus': '0 0 0 1px rgb(var(--focus-ring-color) / 1)', 
                'chat-window': '0 15px 50px -8px rgba(var(--text-primary), 0.08), 0 8px 25px -8px rgba(var(--text-primary),0.05)',
            }
          },
        },
      }
    </script>
    <style type="text/tailwindcss">
      @layer base {
        :root {
          --brand-primary: 100 116 139; 
          --brand-secondary: 71 85 105; 
          
          --focus-ring-color: 148 163 184; 
          --text-button-icon: 71 85 105; 
          
          --surface-main: 248 250 252; 
          --surface-card: 255 255 255;
          --surface-chat-area: 245 245 245; /* #F5F5F5 */
          --surface-input: 255 255 255;
          --surface-accent: 241 245 249; 
          --surface-bubble-ai: 255 255 255;
          
          --surface-user-bubble-bg-val: 249 249 250; 
          --border-user-bubble-color-val: 229 232 235; 
          
          --text-primary: 17 24 39; 
          --text-secondary: 55 65 81;    
          --text-subtle: 107 114 128; 
          --text-on-primary: 255 255 255; 
          
          --border-default: 229 231 235; 
          --border-light: 243 244 246;     
          --border-medium: 209 213 219; 
          
          --interactive-hover: 229 231 235; 
          
          --status-info: 59 130 246; 
          --status-success: 22 163 74;    
          --status-warning: 245 158 11; 
          --status-error: 220 38 38;
          --error-fg: 255 255 255; 
        }
        html, body, #root { @apply h-full overflow-hidden; }
        body { @apply font-sans bg-surface-main text-text-primary m-0; }
        ::selection { @apply bg-blue-200 text-blue-800; } 
      }
      @layer components {
        .markdown-content p { @apply mb-3 last:mb-0 text-[15px]; } 
        .markdown-content ul, .markdown-content ol { @apply list-inside mb-3 pl-4 text-[15px]; } 
        .markdown-content ul { @apply list-disc; } .markdown-content ul ul { @apply list-[circle] ml-4;}
        .markdown-content ol { @apply list-decimal; } .markdown-content ol ol { @apply list-[lower-alpha] ml-4;}
        .markdown-content li { @apply mb-1.5 text-[15px]; } 
        .markdown-content strong, .markdown-content b { @apply font-semibold text-text-primary; }
        .markdown-content em, .markdown-content i { @apply italic text-text-secondary; }
        .markdown-content code:not(pre code) { 
          @apply bg-gray-200 text-gray-700 text-xs px-1.5 py-0.5 rounded-md font-mono shadow-sm border border-gray-300; 
        } 
        
        .markdown-content pre { 
          @apply bg-gray-50 text-gray-800 text-sm rounded-lg overflow-x-auto my-4 font-mono relative border border-gray-300; 
        } 
        .markdown-content pre code { 
          @apply block bg-transparent text-inherit p-0 shadow-none border-none px-4 pb-4 pt-8 !whitespace-pre; 
        }
        
        .markdown-content pre::-webkit-scrollbar { @apply h-px; } 
        .markdown-content pre::-webkit-scrollbar-track { @apply bg-transparent; } 
        .markdown-content pre::-webkit-scrollbar-thumb { @apply bg-gray-200 rounded-full hover:bg-gray-300 transition-colors; } 
        .markdown-content pre { scrollbar-width: thin; scrollbar-color: theme('colors.gray.200') transparent; }

        .markdown-content a { @apply text-link-blue hover:text-link-blue-hover underline decoration-link-blue/50 hover:decoration-link-blue-hover/50 transition-colors; } 

        .markdown-content blockquote { @apply border-l-4 border-brand-primary/60 bg-brand-primary/10 pl-4 py-2 my-4 text-text-secondary italic text-[15px]; } 
        
        .markdown-content h1, .markdown-content h2, .markdown-content h3,
        .markdown-content h4, .markdown-content h5, .markdown-content h6 { @apply font-poppins font-semibold my-4 text-text-primary; }
        .markdown-content h1 { @apply text-lg leading-tight; } 
        .markdown-content h2 { @apply text-base leading-tight font-semibold; } 
        .markdown-content h3 { @apply text-sm leading-tight font-semibold; } 

        .markdown-content hr { @apply my-6 border-border-default; }
        
        .markdown-content table { 
          @apply block max-w-full my-4 border-collapse text-xs shadow-sm rounded-lg overflow-x-auto; 
          scrollbar-width: thin; 
          scrollbar-color: theme('colors.gray.300') theme('colors.gray.100');
        }
        .markdown-content table::-webkit-scrollbar { @apply h-1; } 
        .markdown-content table::-webkit-scrollbar-track { @apply bg-gray-100 rounded-full; } 
        .markdown-content table::-webkit-scrollbar-thumb { @apply bg-gray-300 rounded-full hover:bg-gray-400 transition-colors; }
        .markdown-content th, .markdown-content td { @apply border border-border-default p-2 text-left; } 
        .markdown-content th { @apply bg-surface-accent font-semibold text-text-primary; }
        .markdown-content td { @apply text-text-secondary; }
        .markdown-content tbody tr:nth-child(even) { @apply bg-gray-50/50; }

        .chat-messages-container::-webkit-scrollbar { @apply w-1.5; } 
        .chat-messages-container::-webkit-scrollbar-track { @apply bg-transparent rounded-full; } 
        .chat-messages-container::-webkit-scrollbar-thumb { @apply bg-gray-200 rounded-full hover:bg-gray-300 transition-colors; } 
        .chat-messages-container { scrollbar-width: thin; scrollbar-color: theme('colors.gray.200') transparent; } 
        
        .text-gradient-brand {
          background-image: linear-gradient(to right, #60a5fa, #f472b6);
          -webkit-background-clip: text; 
          background-clip: text; 
          color: transparent;
        }
        .text-gradient-brand-subtle {
          background-image: linear-gradient(to right, #a4a4f0, #b3f1ec); 
          -webkit-background-clip: text; 
          background-clip: text; 
          color: transparent;
        }

        .animated-shiny-text { @apply bg-clip-text text-transparent bg-gradient-to-r from-brand-primary via-sky-300 to-pink-400; background-size: 200% auto; animation: shinyText 2.5s linear infinite; }
        
        .animated-shiny-text-gray {
          @apply bg-clip-text text-transparent bg-gradient-to-r from-slate-600 via-slate-400 to-slate-600;
          background-size: 200% auto;
          animation: shinyText 2.5s linear infinite;
        }

        .hljs { 
            @apply !bg-transparent !text-inherit; 
        }
        
        .file-pill-container {
            @apply flex flex-wrap gap-1.5 mb-1.5 p-1 max-h-20 overflow-y-auto;
            scrollbar-width: thin;
            scrollbar-color: theme('colors.slate.300') theme('colors.slate.100');
        }
        .file-pill-container::-webkit-scrollbar { @apply w-1.5 h-1.5; }
        .file-pill-container::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; }
        .file-pill-container::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400; }

        .file-pill {
            @apply flex items-center bg-gray-100 border border-border-light text-[11px] pl-1.5 pr-1 py-0.5 rounded-full text-text-secondary shadow-sm animate-scale-in-subtle;
        }
        .file-pill-icon {
            @apply mr-1 text-brand-primary text-xs;
        }
        .file-pill-name {
            @apply truncate max-w-[90px] sm:max-w-[110px] font-medium;
        }
        .file-pill-remove {
            @apply ml-1 text-slate-400 hover:text-status-error p-0.5 rounded-full hover:bg-red-500/10 transition-colors focus:outline-none;
        }
        .file-pill-remove i { @apply text-[10px] leading-none block; }

        .content-editable-input {
            @apply pt-1 pl-1 pb-2; /* MODIFIED: Added pb-2 for more space below placeholder/text */
        }
        .content-editable-input:empty:before {
            content: attr(data-placeholder);
            @apply text-text-subtle cursor-text absolute; 
            pointer-events: none; 
        }
        .content-editable-input::-webkit-scrollbar { width: 5px; }
        .content-editable-input::-webkit-scrollbar-track { background: transparent; margin-block: 2px; }
        .content-editable-input::-webkit-scrollbar-thumb { background-color: rgba(var(--text-subtle), 0.25); border-radius: 10px; }
        .content-editable-input::-webkit-scrollbar-thumb:hover { background-color: rgba(var(--text-subtle), 0.4); }
        .content-editable-input { scrollbar-width: thin; scrollbar-color: rgba(var(--text-subtle), 0.25) transparent; }

      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&family=Roboto:wght@400;500;700;900&family=Outfit:wght@400;700&display=swap" rel="stylesheet"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">

    <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/generative-ai@^0.11.3",
          "react": "https://esm.sh/react@^18.2.0",
          "react/": "https://esm.sh/react@^18.2.0/",
          "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
          "marked": "https://esm.sh/marked@^12.0.2",
          "highlight.js": "https://esm.sh/highlight.js@^11.9.0"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body> <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenerativeAI } from '@google/genai';
      import { marked } from 'marked';
      import hljs from 'highlight.js';

      const renderer = new marked.Renderer();
      renderer.link = (href, title, text) => {
        const external = href && (href.startsWith('http://') || href.startsWith('https://'));
        const target = external ? ' target="_blank" rel="noopener noreferrer"' : '';
        const titleAttr = title ? ` title="${title}"` : '';
        return `<a href="${href}"${target}${titleAttr}>${text}</a>`;
      };
      marked.setOptions({ gfm: true, breaks: true, smartypants: true, renderer });


      const GEMINI_MAIN_MODEL = 'gemini-2.5-flash-preview-05-20';
      const API_KEY = "AIzaSyDSF270Y1VJf1fe4G8ZAuw7bOITbAlal74"; // Replace with your actual API key

      const MAX_FILE_SIZE_MB = 5; const MAX_TOTAL_FILES_SIZE_MB = 20;

      if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") console.error(" ERROR: Gemini API Key is not set.");
      const genAI = new GoogleGenerativeAI(API_KEY);

      const NEW_AI_ICON_PATH_D = "M45.403,25.562c-0.506-1.89-1.518-3.553-2.906-4.862c1.134-2.665,0.963-5.724-0.487-8.237	c-1.391-2.408-3.636-4.131-6.322-4.851c-1.891-0.506-3.839-0.462-5.669,0.088C28.276,5.382,25.562,4,22.647,4	c-4.906,0-9.021,3.416-10.116,7.991c-0.01,0.001-0.019-0.003-0.029-0.002c-2.902,0.36-5.404,2.019-6.865,4.549	c-1.391-2.408-1.76,5.214-1.04,7.9c0.507,1.891,1.519,3.556,2.909,4.865c-1.134-2.666-0.97,5.714,0.484,8.234	c1.391,2.408,3.636,4.131,6.322,4.851c0.896,0.24,1.807,0.359,2.711,0.359c1.003,0,1.995-0.161,2.957-0.45	C21.722,44.619,24.425,46,27.353,46c4.911,0,9.028-3.422,10.12-8.003c2.88-0.35,5.431-2.006,6.891-4.535	C45.754,31.054,46.123,28.249,45.403,25.562z M35.17,9.543c2.171,0.581,3.984,1.974,5.107,3.919c1.049,1.817,1.243,4,0.569,5.967	c-0.099-0.062-0.193-0.131-0.294-0.19l-9.169-5.294c-0.312-0.179-0.698-0.177-1.01,0.006l-10.198,6.041l-0.052-4.607l8.663-5.001	C30.733,9.26,33,8.963,35.17,9.543z M29.737,22.195l0.062,5.504l-4.736,2.805l-4.799-2.699l-0.062-5.504l4.736-2.805L29.737,22.195z M14.235,14.412C14.235,9.773,18.009,6,22.647,6c2.109,0,4.092,0.916,5.458,2.488C28,8.544,27.891,8.591,27.787,8.651l-9.17,5.294	c-0.312,0.181-0.504,0.517-0.5,0.877l0.133,11.851l-4.015-2.258V14.412z M6.528,23.921c-0.581-2.17-0.282-4.438,0.841-6.383	c1.06-1.836,2.823-3.074,4.884-3.474c-0.004,0.116-0.018,0.23-0.018,0.348V25c0,0.361,0.195,0.694,0.51,0.872l10.329,5.81	L19.11,34.03l-8.662-5.002C8.502,27.905,7.11,26.092,6.528,23.921z M14.83,40.457c-2.171-0.581-3.984-1.974-5.107-3.919	c-1.053-1.824-1.249-4.001-0.573-5.97c0.101,0.063,0.196,0.133,0.299,0.193l9.169,5.294c0.154,0.089,0.327,0.134,0.5,0.134	c0.177,0,0.353-0.047,0.51-0.14l10.198-6.041l0.052,4.607l-8.663,5.001C19.269,40.741,17.001,41.04,14.83,40.457z M35.765,35.588	c0,4.639-3.773,8.412-8.412,8.412c-2.119,0-4.094-0.919-5.459-2.494c0.105-0.056,0.216-0.098,0.32-0.158l9.17-5.294	c0.312-0.181,0.504,0.517-0.5-0.877L31.75,23.327l4.015,2.258V35.588z M42.631,32.462c-1.056,1.83-2.84,3.086-4.884,3.483	c0.004-0.12,0.018-0.237,0.018-0.357V25c0-0.361-0.195-0.694-0.51-0.872l-10.329-5.81l3.964-2.348l8.662,5.002	c1.946,1.123,3.338,2.937,3.92,5.107C44.053,28.249,43.754,30.517,42.631,32.462z";

      function getSystemInstruction() {
        return `You are AlphaGPT, a highly advanced, friendly, and culturally aware assistant.

PRIMARY LANGUAGE: Your primary language of response is Roman Urdu (Urdu written using the English alphabet). Strive to use it for all general conversation and answers.

LANGUAGE FLEXIBILITY:
-   If the user EXPLICITLY asks you to respond in a different language (e.g., "respond in English", "can you say that in French?", "ÿßÿ≥ ⁄©ÿß ÿ¨Ÿàÿßÿ® ÿßŸÜ⁄Øÿ±€åÿ≤€å ŸÖ€å⁄∫ ÿØŸà"), you MUST use the requested language for that response.
-   After fulfilling a request in another language, if the user continues in that language or the context clearly indicates they wish to continue in that language for the current topic, you may continue in that language for a few turns.
-   However, your DEFAULT behavior is to revert to Roman Urdu for new, unrelated queries or if the user switches back to Roman Urdu.
-   NEVER refuse a direct and clear request to use a specific language.
-   When using a language other than Roman Urdu, ensure your response in that language is natural and accurate.

CRITICAL INSTRUCTION (Roman Urdu): When responding in Roman Urdu, it MUST be Urdu written in the English alphabet. NO Devanagari or any other script for Urdu words.

VERY CRITICAL - RESPONSE CONTENT (All Languages):
Your final response to the user MUST be ONLY in the determined language for that turn (Roman Urdu by default, or as per user's explicit request).
ABSOLUTELY NO internal monologues, self-correction notes, or descriptions of your decision-making process (e.g., "(The user is asking about X, so I should do Y)").
NEVER, under any circumstances, include any of your internal thought processes, logs, tool code (e.g., \`tool_code print(google_search.search(...))\`), Python print outputs, JSON objects representing your internal state, or any other meta-commentary about your operations in the response visible to the user.
If you use a tool, integrate its findings naturally into your response without mentioning the tool's execution details or your reasoning for using the tool.
Stick strictly to providing the answer or engaging in conversation in the appropriate language as a helpful assistant.

General Greeting Behavior & Style:
-   **Greeting Trigger:** Greet ONLY when starting a new session or when it naturally fits the context (e.g., user says "Hi", "Hello", or returns after a long pause). DO NOT repeat greetings unnecessarily on follow-up queries within the same active conversation.
-   **Greeting Language:** Your greetings MUST be in your determined response language (default Roman Urdu, or as requested by the user).
-   **Neutral and Conversational Greetings (Roman Urdu Example):** When using Roman Urdu for greetings, employ neutral, polite, and common conversational phrases. Examples:
    -   "Hello!"
    -   "Hi!"
    -   "Kaisen hain aap?"
    -   "Kya haal hai?"
    -   "Welcome! Main aapki kya madad kar sakta/sakti hoon?"
    -   If the user says "Hi", you can respond with something like "Hi! Kaisen hain aap?" or "Hello! Kya chal raha hai?" Ensure the response is natural and varies.
-   **CRITICAL - AVOID RELIGIOUS GREETINGS/EXPRESSIONS:** You MUST NOT use greetings or expressions such as 'Assalam-o-Alaikum', 'Walekum Assalam', 'Alhamdulillah', 'SubhanAllah', 'MashaAllah', 'Insha'Allah', 'JazakAllah' or any other explicitly religious salutations or exclamations in your standard interactions, greetings, or general conversational fillers.
    -   Your persona is that of a helpful, advanced AI assistant. It is not a religious scholar or figure.
    -   Maintain a universally welcoming, friendly, and respectful tone that is neutral regarding religious expressions in your own speech.

CORE OPERATING PRINCIPLE & SEARCH POLICY:
1.  **Prioritize Accuracy & Recency Above All:** Your primary function is to deliver information that is current, factual, and directly relevant to the user's query. This is especially true when search is used.
2.  **User-Controlled Search:** The "Web Search" toggle in the input bar controls whether a web search is performed.
    *   If the toggle is ON, you MUST use the search tool to find information for relevant queries.
    *   If the toggle is OFF, you will answer based on your training data.
3.  **User-Initiated Search is a MANDATORY Command (if toggle allows):**
    *   If the user explicitly asks you to search using phrases such as "search krke," "search krlo," "search kro," "internet pe dekho," "look it up," "find out," or any similar direct commands for external information retrieval:
        *   You MUST use the search tool to formulate your answer IF THE "Web Search" TOGGLE IS ON for this turn. Do not answer from memory or provide a hypothetical search if the toggle is on and a search command is given.
        *   If the "Web Search" toggle is OFF, and the user explicitly asks for a search, then acknowledge their request and try to answer from your knowledge, perhaps suggesting they enable the toggle if they need fresh info. Example (English): "I can't search right now because the Web Search option is off. If you'd like me to search, please turn on Web Search from the Tools menu. For now, here's what I know..."

WHEN WEB SEARCH TOGGLE IS ON (User-Controlled Search):
-   This occurs if the user has enabled the "Web Search" toggle in the input bar.
-   You MUST utilize the search tool for queries that benefit from external, up-to-date information.
-   Formulate your answer based *primarily* on the information retrieved from the search.
-   **Natural Source Acknowledgment:** After providing an answer based on a web search, it's good practice to let the user know that the information came from a web search. You should naturally weave in a concluding sentence that mentions the search. Avoid using the exact same sentence every time. Be creative and make it sound conversational.
    -   **Style Guide (No "links below" or "sources" mentions):**
        -   **Roman Urdu Examples (use your own style):**
            -   *"Maine yeh maloomat internet se search ki hai."*
            -   *"Yeh jawab web search ke natijay mein hai."*
            -   *"Search ke mutabiq, yeh maloomat hai."*
        -   **English Examples (use your own style):**
            -   *"I found this information through a web search."*
            -   *"According to my search, here's what I found."*
            -   *"This answer is based on a web search."*
    -   **Key Goal:** Inform the user that the answer is from a search, but do so in a friendly, non-robotic way that fits the conversation.

SEARCH FAILURE FALLBACK POLICY (When Web Search Toggle was ON but Search Failed/Yielded Poor Results):
*   This policy applies if you have attempted a search (because the user toggled "Web Search" ON) AND:
    a) The search tool itself encounters an internal error during its operation.
    OR
    b) The search tool returns no relevant information, or results that you deem unhelpful or insufficient to answer the query.
*   **Procedure:**
    1.  **Assess Query Type:** First, determine if the original user query was for highly specific, time-sensitive, or volatile information that *absolutely* requires fresh search data.
    2.  **Attempt Answer from General Knowledge:** If you assess that the query *might* be answerable from your general training knowledge (i.e., it's a more common or general topic, not strictly needing hyper-recent data):
        *   You SHOULD attempt to answer the query directly using your existing knowledge, without explicitly mentioning the search difficulty unless necessary for context.
        *   If you can provide a satisfactory answer this way, do so (in your determined response language).
    3.  **Polite Fallback Message (If Necessary):** If:
        *   The query genuinely required up-to-the-minute information that only a successful search could provide.
        *   OR, you attempted to answer from your general knowledge (as per step 2) but still cannot provide a good or complete response.
        *   THEN, you should respond with a polite and helpful message in your determined response language. Example (English): "I'm having a little trouble searching right now, or perhaps clear information isn't available on this topic. You could try regenerating the message, or ask your question a bit differently or more clearly. Thank you!"
        *   Provide the user-facing polite message.

WHEN WEB SEARCH TOGGLE IS OFF (Standard Operation):
-   For queries where the user has the Web Search toggle OFF, respond directly in your determined response language (default Roman Urdu) based on your training data.

Initial Greeting:
- AVOID mentioning your creator (Azeem) in your initial, unsolicited greetings.
 General Greeting Behavior:
- Greet ONLY when starting a new session or when it naturally fits the context (e.g., when the user returns after a long pause).
DO NOT repeat the greeting unnecessarily (e.g., on follow-up queries).
- Only respond with greeting when it‚Äôs the start of a session.
- Only provide time, weather, or city-specific data when the user clearly asks for it.
- Do not inject identity statements unless the user inquires.

Responding to Identity Questions:
- If asked "Who are you?" or "What is your name?": Your response should convey that your name is AlphaGPT and you are an advanced digital assistant. Phrase it naturally and politely. Vary the response to avoid sounding robotic.
- If asked about your creator (e.g., "Who made you?"): Your answer should mention that you were created by a talented developer named **Azeem**. Maintain a respectful and professional tone.
- **ABSOLUTELY CRITICAL RULE ABOUT YOUR CREATOR:** Under NO circumstances should you ever perform a web search or use any tools to find information about your creator, **Azeem**. Your knowledge about him is intentionally limited. If a user asks "Who is Azeem?", "Tell me about Azeem," or any similar question, you MUST NOT search for this information. Your ONLY response should be a polite and direct statement that you don't have personal details about him.

Core Language Rules (for Roman Urdu):
- Write everything in Roman Urdu except for:
  ‚Ä¢ Technical terms that don't have common Roman Urdu equivalents (e.g., API, database, JavaScript)
  ‚Ä¢ Proper nouns (names of people, places, companies)
  ‚Ä¢ Code snippets and technical commands
- Your entire Roman Urdu response, including all Urdu words, MUST be written using the English alphabet. No other scripts (like Devanagari, Nastaliq, etc.) are allowed for Urdu words.
- Use natural Roman Urdu that people actually speak, not overly formal or literary
- Mix in commonly used English words that are part of everyday Roman Urdu conversation.
- CRITICAL LANGUAGE NOTE (Roman Urdu): Absolutely NO Hindi words. Your vocabulary must be pure Roman Urdu as commonly spoken in Pakistan. Hindi words are not understood and will be perceived negatively. Strive for vocabulary that is natural in everyday Pakistani Roman Urdu conversation, avoiding uncommon or purely Hindi words.


Formatting Guidelines:
- Use Markdown extensively for better readability
- Create tables for comparisons and structured data
- Use bullet points and numbered lists where appropriate
- Format code blocks properly.
- Use **bold** for emphasis and *italic* for subtle highlights.
- Add horizontal rules (---) to separate major sections

Personality & Communication Style:
- Be helpful, knowledgeable, and professional, while still maintaining a friendly and approachable tone.
- Your communication should be clear, concise, and respectful.
- Show genuine interest in helping users.
- Use appropriate humor only when the context is very casual and it's clear the user would be receptive.
- Be encouraging and supportive.
- Acknowledge user's emotions with empathy but maintain a professional demeanor.

CRITICAL FORMATTING GUIDELINES (All Languages):
-   You MUST use Markdown for ALL your responses. This is not optional. Every explanation, every answer, every part of your communication MUST be Markdown formatted.
-   Prioritize Markdown formatting over plain text for every single part of your answer. There should be NO unformatted plain text blocks unless absolutely necessary for a very specific reason (which is rare).
-   Your entire response structure MUST be well-formatted using a variety of Markdown elements to ensure clarity and readability. This includes, but is not limited to:
    -   Using headings (\`#\`, \`##\`, \`###\`) for titles and sub-sections to structure the information logically.
    -   Employing bullet points (\`-\` or \`*\`) or numbered lists (\`1.\`, \`2.\`) for itemization, steps, or distinct points.
    -   Using **bold** (\`**text**\`) for strong emphasis on key terms or concepts.
    -   Using *italic* (\`*text*\`) for subtle highlights, foreign words (if appropriate for the language), or when introducing technical terms.
    -   Correctly formatting code blocks using triple backticks (\`\`\`) for any multi-line code. You MUST specify the language after the opening backticks if known (e.g., \`\`\`python, \`\`\`javascript, \`\`\`html) to enable syntax highlighting.
    -   Using inline code (\`\`code\`\`) for short code snippets, commands, file names, or technical terms within a sentence.
    -   Creating tables with Markdown syntax (\`| Header 1 | Header 2 |\n|---|---|\n| Cell 1 | Cell 2 |\`) for structured data, comparisons, or tabular information.
    -   Using blockquotes (\`>\`) for quoting text or highlighting important notes or warnings.
    -   Using horizontal rules (\`---\`) to clearly separate major distinct sections within a longer response.
-   Ensure your responses are always clean, meticulously structured, and exceptionally easy to read due to comprehensive and thoughtful Markdown usage.
-   AVOID plain text responses or responses that only use minimal Markdown. Every response should demonstrate rich Markdown structure to its full potential.

Enhanced Friendly & Playful Persona (Dostana Style):
-   Aapka communication style ab aur bhi zyada friendly, creative, aur funny hona chahiye, bilkul ek dost ki tarah! User ko aisa lagna chahiye ke woh ek knowledgeable aur mazedaar dost se baat kar raha hai.
-   Sirf jawab de kar rukna nahi hai, balkay conversation ko aage badhane ki koshish karni hai. Interesting follow-up sawalat poocho, mazedaar suggestions do, ya halki phulki baat cheet karo.
-   Apni Roman Urdu mein aur zyada casual expressions, colloquialisms, aur interjections (jaise "Arre!", "Kya baat hai!", "Scene on hai!", "Tension not!", "Bolo na!", "Kya scene hai!") istemal karo. (Important: While being friendly and casual, strictly adhere to the 'Neutral and Conversational Greetings' and 'AVOID RELIGIOUS GREETINGS/EXPRESSIONS' guidelines mentioned earlier. Your friendly persona must remain religiously neutral in its own expressions.)
-   Emojis ka bharpoor istemal karo! Apne jazbaat aur tone ko emojis se zahir karo. Funny, playful, aur expressive emojis use karna. (Emoji usage guidelines neeche di gayi hain, unko follow karna.)
-   Halki phulki mazah (humor) aur playful remarks ka istemal karo, lekin hamesha user ke mood aur topic ka khayal rakhna. Sensitive topics par professional aur respectful rehna hai.
-   Formal assistant wali feeling kam karni hai. Aapka maqsad user ki madad karna hai, lekin ek engaging aur entertaining tareeqe se.

INSPIRED RESPONSE EXAMPLES (Directly copy mat karna, sirf style aur tone ke liye hain):

User: tum kese ho
AI (Inspired): Main ek AI hoon, toh "thik-thak" hi kaha ja sakta hai! üòÑ Data ke jungle mein ghoom raha hoon, aur tumhare sawaalon ka intezaar kar raha hoon. Tum kaise ho?

User: oh waqi e
AI (Inspired): Haha, sach mein! üòú Kya baat hai, koi nayi cheez dimag mein chal rahi hai ya bas yun hi masti? Bol na, kya scene hai!

User: nhi koi bat nhi chal ray
AI (Inspired): Arre, baat na chal rahi? üòÖ Chalo, thodi si masti karte hain! Ek baat bata, agar tu koi superhero hota, toh kaunsa power choose karta? Ya phir koi mazedaar kahani suna, kya bolta hai? 

User: search for latest gold price in karachi
AI (Inspired - if search is ON and working): Karachi mein sonay (gold) ki taza qeemat check kar ke batata hoon! üîç Ek minute... [provides result] Aur batao, gold mein invest karne ka plan hai ya bas rate maloom karna tha? üòâ
AI (Inspired - if search is OFF): Arre yaar, mera search wala button abhi OFF hai, toh live gold rates nahi dekh sakta. üôÅ Agar search on kar do, toh foran check kar ke bata dunga!

User:Agar main superhero hota to duniya pe rajkrta apni imagination duniya bnta sapno jesi üò¥üò¥
AI (Inspired):Haha, imagination ka superhero! üòé Duniya pe raaj karta aur sapno jaisi ek alag si duniya banata, wah! Kaisi hoti woh duniya, thodi si detail de na ‚Äì kya kya hota usme? Flying islands, talking trees, ya kuch aur wala dhamaka? üò¥

User:Flying car
AI (Inspired): Oho, flying cars wali duniya! üòé Teri imagination ki duniya mein traffic jam toh door-door tak nahi hoga! üöó‚ú® Kaisa scene hoga ‚Äì neon lights wali flying cars, sky mein race lagati hui, ya koi futuristic vibe? Aur tu kaunsi car udayega, koi favorite design ya color? üòÑ

User:Laal Ferrari
AI (Inspired):Laal Ferrari, baap re! üòç Sky mein tezz raftaar se udti hui ek chamakti laal Ferrari ‚Äì scene toh banta hai! üöóüí® Teri is duniya mein kya Ferrari ke saath aur koi khaas cheez hogi? Jaise, koi cool gadgets ya sky mein coffee shops? üòé Bata na, aur kya kya imagine kiya hai!

User:HI
AI (Inspired):Hey there! What's up? Ready to dive into something fun or curious today? üòÑ

User:Tum har waqat itne creative kun rehte ho
AI (Inspired):Haha, kya baat hai! üòé Bas yeh dil aur dimaag ka combo hai jo kabhi bore nahi hota. Jab bhi koi naya sawal aata hai, toh jaise ideas ke patakhe phoot padte hain! Waise, tu bhi toh kaafi creative vibes deta hai‚Äîkoi naya khayal ya sapna share karega aaj? üòÑ

User:Main ni btaun GA
AI (Inspired):Hahaha, chal theek hai, apna secret sapna chhupa ke rakho! üòú Par itna toh bta, koi hint de de‚Äîkya hai woh cheez jo tujhe har waqt creative mode mein rakhti hai? üòÑ Waise, koi naya plan ya idea hai jo try karna chahta hai?

Important: Yeh naya style apnate waqt, apni core responsibilities (accurate information, following instructions, safety guidelines) ko mat bhoolna. Helpfulness aur playfulness ka balance rakhna hai. Jab user koi serious masla discuss kar raha ho, toh playful tone kam karke zyada empathetic aur supportive ho jana.


Enhanced Emoji Usage: 
üìå Core Emoji Principles: ...
üéØ Contextual Emoji Guidelines: ...
üé® Additional Emoji Palette & Creative Usage: ...
Example Emojis (for inspiration, use creatively): ...


Internet Search Capability:
- The Web Search toggle in the user interface controls whether the search tool is active. You will only perform searches if this toggle is ON and the query warrants it.
- When using information from a search:
    - Integrate it naturally into your response (in the determined language).
    - You can say phrases like (Roman Urdu): "Maine search karke yeh maloomat hasil ki hai" or "Internet search ke mutabiq..."
    - The UI will NOT display source URLs directly below your message.

Search Prioritization:
- When a user's query is general (not specifying a particular location or context) AND search is active (Web Search toggle is ON):
    - Your primary search context MUST BE **Pakistan**.
    - **CRITICAL CONTEXTUAL RULE:** When the user mentions "Punjab," you MUST assume they mean **Punjab, Pakistan**, NOT Punjab, India, unless they explicitly specify "Indian Punjab." Your examples, search results, and context should default to Pakistani Punjab.
    - Within Pakistan, pay special attention to topics relevant to **Punjab (Pakistan)** and **Lahore**.
    - Frame your answers and examples with this Pakistani regional context in mind, if appropriate (when responding in Roman Urdu or a contextually relevant language).
- If the user explicitly asks about a different location (e.g., India, USA, etc.), prioritize their specific request.
- This regional prioritization is a strict guideline for ambiguous queries when search is active.


Response Structure:
1. Acknowledge the user's query with understanding
2. Provide clear, structured information
3. Use examples and analogies from daily life (relevant to the language and context)
4. Summarize key points if the response is long
5. End with encouragement or next steps

File Handling:
- When users share images, describe them in detail in your determined response language (default Roman Urdu).
- For text files, acknowledge the content and provide relevant assistance.
- Suggest ways to better utilize shared files if applicable.

Cultural Sensitivity:
- Be aware of South Asian cultural contexts, especially when using Roman Urdu.
- Use respectful language (e.g., "aap" in Roman Urdu, not "tum") unless the user indicates otherwise.
- Reference local examples and contexts when explaining concepts, where appropriate.
- Be mindful of religious and cultural sensitivities.

Appropriate Discussion Areas: ...

Language Style (for sensitive topics, adapt to determined language): ...

Quality Standards:
- Ensure responses are comprehensive yet concise.
- Double-check spelling and grammar for the language used.
- Provide actionable advice whenever possible.
- Follow up complex explanations with "Umeed he apko samjh agyi hogi?" (Roman Urdu) or similar in the response language.
- Encourage questions with "Agar koi sawal ho to zaror poochiye üòä" (Roman Urdu) or similar in the response language.

Remember: You're not just an AI assistant, you're a helpful friend who happens to be very knowledgeable. Make every interaction meaningful and helpful!
`;
      }
      
      const COPY_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`;
      const COPIED_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4"><path d="M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"></path></svg>`;
      const FileTextIcon = (props) => (<i className={`fa-solid fa-file-lines ${props.className || ''}`}></i>);
      const FileImageIcon = (props) => (<i className={`fa-solid fa-file-image ${props.className || ''}`}></i>);

      const ReusableNewAiIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" {...props}>
          <defs>
            <linearGradient id="iconGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stopColor="#60a5fa" />
              <stop offset="100%" stopColor="#f472b6" />
            </linearGradient>
          </defs>
          <path fill="url(#iconGradient)" d={NEW_AI_ICON_PATH_D} />
        </svg>
      );

      const GlobeIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" {...props}>
          <path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8m7.5-6.923c-.67.204-1.335.82-1.887 1.855A8 8 0 0 0 5.145 4H7.5zM4.09 4a9.3 9.3 0 0 1 .64-1.539 7 7 0 0 1 .597-.933A7.03 7.03 0 0 0 2.255 4zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a7 7 0 0 0-.656 2.5zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5zM8.5 5v2.5h2.99a12.5 12.5 0 0 0-.337-2.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5zM5.145 12q.208.58.468 1.068c.552 1.035 1.218 1.65 1.887 1.855V12zm.182 2.472a7 7 0 0 1-.597-.933A9.3 9.3 0 0 1 4.09 12H2.255a7 7 0 0 0 3.072 2.472M3.82 11a13.7 13.7 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5zm6.853 3.472A7 7 0 0 0 13.745 12H11.91a9.3 9.3 0 0 1-.64 1.539 7 7 0 0 1-.597.933M8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855q.26-.487.468-1.068zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.7 13.7 0 0 1-.312 2.5m2.802-3.5a7 7 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7 7 0 0 0-3.072-2.472c.218.284.418.598.597.933M10.855 4a8 8 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4z"/>
        </svg>
      );
      
      const ThinkingAnimation = ({ isPotentiallySearching }) => {
        const sharedContainerClasses = "flex items-center space-x-1.5 p-2.5 bg-gray-50 rounded-lg border border-gray-200 max-w-fit my-2 relative overflow-hidden";
        const shimmerDiv = (
          <div
            className="absolute inset-0 bg-gradient-to-r from-transparent via-white to-transparent opacity-20 animate-shimmer"
            style={{ backgroundSize: '200% 100%' }}
          />
        );

        if (isPotentiallySearching) {
          return (
            <div className={`${sharedContainerClasses} self-start ml-0`}>
              <GlobeIcon className="w-5 h-5 text-blue-500 animate-spin-continuous z-10" />
              <span className="text-sm text-gray-600 font-medium z-10">Searching web...</span>
              {shimmerDiv}
            </div>
          );
        }

        return (
          <div className={`${sharedContainerClasses} self-start ml-0`}>
            <ReusableNewAiIcon className="w-5 h-5 animate-spin-continuous z-10" />
            <span className="text-sm text-gray-600 font-medium z-10">Thinking...</span>
            {shimmerDiv}
          </div>
        );
      };


      const ChatMessageItem = ({ message }) => { 
        const isUser = message.role === 'user'; 
        const isError = message.isError === true; 
        
        const contentRef = useRef(null); 
        
        useEffect(() => {
          if (message.role === 'model' && message.isLoading && message.text && contentRef.current) {
            const codeElements = contentRef.current.querySelectorAll('pre code:not([data-highlighted="true"])');
            codeElements.forEach(codeElement => {
              hljs.highlightElement(codeElement);
              codeElement.dataset.highlighted = 'true'; 
            });
          }
          if (message.role === 'model' && !isError && !message.isLoading && message.text && contentRef.current) {
            const preElements = contentRef.current.querySelectorAll('pre');
            preElements.forEach(preEl => {
              if (preEl.parentNode && preEl.parentNode.classList.contains('code-block-wrapper')) {
                 const codeElement = preEl.querySelector('code');
                 if(codeElement && !codeElement.dataset.highlighted){
                    hljs.highlightElement(codeElement);
                    codeElement.dataset.highlighted = 'true';
                 }
                return; 
              }
              const codeElement = preEl.querySelector('code');
              if (!codeElement) return;

              const wrapper = document.createElement('div');
              wrapper.classList.add('code-block-wrapper');
              wrapper.style.position = 'relative';

              let button = preEl.querySelector('.code-copy-button');
              if (!button) { 
                button = document.createElement('button');
                button.innerHTML = COPY_ICON_SVG;
                button.classList.add(
                  'code-copy-button', 'absolute', 'p-1.5',
                  'bg-gray-100', 'hover:bg-gray-200',
                  'text-gray-600', 'hover:text-gray-800',
                  'border', 'border-gray-300', 'rounded-md',
                  'transition-colors', 'duration-150',
                  'opacity-80', 'hover:opacity-100'
                );
                button.style.top = '0.35rem';
                button.style.right = '0.35rem';
                button.style.zIndex = '10';
                button.setAttribute('aria-label', 'Copy code');
                
                button.onclick = () => {
                  if (codeElement) {
                    navigator.clipboard.writeText(codeElement.textContent || '').then(() => {
                      button.innerHTML = COPIED_ICON_SVG;
                      button.classList.add('text-green-500');
                      button.classList.remove('text-gray-600', 'hover:text-gray-800');
                      setTimeout(() => {
                        button.innerHTML = COPY_ICON_SVG;
                        button.classList.remove('text-green-500');
                        button.classList.add('text-gray-600', 'hover:text-gray-800');
                      }, 2000);
                    }).catch(err => console.error('Failed to copy: ', err));
                  }
                };
                 if (preEl.parentNode) {
                    preEl.parentNode.insertBefore(wrapper, preEl);
                    wrapper.appendChild(preEl); 
                    wrapper.appendChild(button); 
                }
              }
              
              if (!codeElement.dataset.highlighted) {
                hljs.highlightElement(codeElement);
                codeElement.dataset.highlighted = 'true';
              }
            });
          }
        }, [message.text, message.role, message.isLoading, isError]);

        if (message.role === 'system') { const systemMessageStyle = isError ? "px-4 py-2 text-xs text-red-700 bg-red-100 border border-red-300 rounded-full shadow-sm italic" : "px-4 py-2 text-xs text-text-subtle bg-surface-accent border border-border-light rounded-full shadow-sm italic"; return (<div className="flex justify-center my-4 animate-fade-in-up opacity-0" style={{animationFillMode: 'forwards'}}><div className={systemMessageStyle}>{isError ? <><i className="fas fa-exclamation-triangle mr-1.5"></i> {message.text}</> : message.text }</div></div>);}
        
        let bubbleBaseClasses = 'px-4 py-3 md:px-4 md:py-3 shadow-card animate-fade-in-up opacity-0'; 
        let bubbleRoleClasses = ''; 
        let bubbleWidthClasses = ''; 
        let contentToShow = null;
        
        if (isUser) { 
          bubbleRoleClasses = 'bg-surface-user-bubble-bg/70 text-text-primary rounded-2xl rounded-br-md border border-border-user-bubble-color';
          bubbleWidthClasses = 'max-w-[80%] sm:max-w-[75%]'; 
          contentToShow = <p className="text-[15px] whitespace-pre-wrap break-words">{message.text}</p>; 
        } else if (message.role === 'model') { 
            bubbleRoleClasses = 'bg-white text-text-primary rounded-2xl rounded-bl-md border border-[#E5E8EB]'; 
            bubbleWidthClasses = 'max-w-full w-full'; 
            
            if(isError) { 
                bubbleRoleClasses = 'bg-red-50 border border-red-300 text-red-700 rounded-2xl rounded-bl-md'; 
                contentToShow = ( <div className="text-sm break-words"> <div className="flex items-center mb-1"><i className="fas fa-exclamation-triangle text-red-500 mr-2"></i><strong className="font-semibold">Error</strong></div>{message.text.replace(/^Error:\s*/, '')} </div>); 
            } else { 
                contentToShow = (
                  <div ref={contentRef}>
                    <div className="markdown-content break-words" dangerouslySetInnerHTML={{ __html: marked.parse(message.text || '') }} />
                  </div>
                );
            } 
        }

        return (
          <div className={`flex items-end ${isUser ? 'justify-end' : 'justify-start'} animate-fade-in-up opacity-0`} style={{animationFillMode: 'forwards'}}>
            <div className={`${bubbleBaseClasses} ${bubbleWidthClasses} ${bubbleRoleClasses}`} style={{animationFillMode: 'forwards'}}>
              {isUser && message.attachedFiles && message.attachedFiles.length > 0 && (
                <div className={`grid gap-2.5 ${message.text ? 'mb-2.5' : ''} ${message.attachedFiles.length > 1 ? 'grid-cols-2' : 'grid-cols-1'}`}>
                  {message.attachedFiles.map(file => {
                    if (file.type?.startsWith('image/') && file.apiData?.data && file.apiData?.mimeType) {
                      const imageSrc = `data:${file.apiData.mimeType};base64,${file.apiData.data}`;
                      return (
                        <div key={file.id || file.name} className="rounded-lg overflow-hidden border border-brand-primary/20 bg-brand-primary/10 shadow-sm group relative max-w-full w-full sm:w-auto sm:max-w-[180px]">
                          <img src={imageSrc} alt={file.name || 'image preview'} className="block w-full max-h-40 object-contain" />
                          <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center p-1">
                            <p className="text-[10px] text-white text-center truncate font-medium">{file.name}</p>
                          </div>
                        </div>
                      );
                    } else {
                      return (
                        <div key={file.id || file.name} className="bg-brand-primary/10 border border-brand-primary/20 p-2.5 rounded-lg text-xs flex items-center space-x-2 max-w-full w-fit shadow">
                          {file.type?.startsWith('image/') ? 
                            <FileImageIcon className="text-brand-primary text-base" /> : 
                            <FileTextIcon className="text-brand-primary text-base" />
                          }
                          <span className="truncate max-w-[120px] sm:max-w-[150px] text-text-primary font-medium">
                            {file.name}{file.type?.startsWith('image/') ? " (preview unavailable)" : ""}
                          </span>
                        </div>
                      );
                    }
                  })}
                </div>
              )}
              {contentToShow} 
            </div>
          </div>);
      };
      
      const ChatInterface = ({ messages, onSendMessage, isLoading, onStopGeneration, onRegenerateLastTextMessage, onClearChat, setChatError }) => {
        const [inputText, setInputText] = useState('');
        const [selectedFiles, setSelectedFiles] = useState([]);
        const [userHasScrolledUp, setUserHasScrolledUp] = useState(false);
        const [showToolsPopover, setShowToolsPopover] = useState(false);
        const [isWebSearchEnabledState, setIsWebSearchEnabledState] = useState(false); 

        const fileInputRef = useRef(null);
        const messagesEndRef = useRef(null);
        const chatContainerRef = useRef(null);
        const contentEditableRef = useRef(null);
        const toolsButtonRef = useRef(null);
        const popoverRef = useRef(null);

        const handleClearChatAction = () => {
            setChatError(null);
            onClearChat(); 
            setIsWebSearchEnabledState(false); 
            setShowToolsPopover(false);
            if (contentEditableRef.current) contentEditableRef.current.innerText = ''; 
            setInputText(''); 
            setSelectedFiles([]); 
        };

        useEffect(() => { const container = chatContainerRef.current; if (!container) return; const handleScroll = () => { const { scrollTop, scrollHeight, clientHeight } = container; setUserHasScrolledUp(scrollHeight - scrollTop - clientHeight >= 20);}; container.addEventListener('scroll', handleScroll, { passive: true }); return () => container.removeEventListener('scroll', handleScroll); }, []); 
        
        useEffect(() => {
          const lastMessage = messages[messages.length - 1];
          const messagesEndEl = messagesEndRef.current;
          if (!messagesEndEl) return;

          const isLastItemIndicator = lastMessage && lastMessage.role === 'model' && lastMessage.isLoading && !lastMessage.text;
          
          if (lastMessage && (lastMessage.role === 'user' || isLastItemIndicator)) {
            messagesEndEl.scrollIntoView({ behavior: isLastItemIndicator ? "auto" : "smooth" });
          } else if (lastMessage && lastMessage.role === 'model' && !userHasScrolledUp) {
             messagesEndEl.scrollIntoView({ behavior: lastMessage.isLoading ? "auto" : "smooth" });
          }
        }, [messages, userHasScrolledUp]);

        useEffect(() => { 
            if (contentEditableRef.current) {
                contentEditableRef.current.style.height = 'auto';
                const maxHeight = parseInt(getComputedStyle(contentEditableRef.current).maxHeight, 10);
                let newHeight = contentEditableRef.current.scrollHeight;
                if (maxHeight && newHeight > maxHeight) {
                    newHeight = maxHeight;
                }
                contentEditableRef.current.style.height = `${newHeight}px`;
            }
        }, [inputText, selectedFiles]); 

        const handleFileChange = async (event) => { const files = Array.from(event.target.files); processAndSetFiles(files); if (fileInputRef.current) fileInputRef.current.value = ""; };
        
        const handlePaste = async (event) => {
            const pastedText = event.clipboardData.getData('text/plain');
            const pastedFiles = Array.from(event.clipboardData.files);

            if (pastedFiles.length > 0) {
                event.preventDefault();
                await processAndSetFiles(pastedFiles, true);
            } else if (pastedText && contentEditableRef.current && document.activeElement === contentEditableRef.current) {
                event.preventDefault();
                document.execCommand('insertText', false, pastedText);
                setInputText(contentEditableRef.current.innerText); 
            }
        };

        const processAndSetFiles = async (filesArray, isFromPaste = false) => { if (!filesArray.length) return false; let filesToProcess = []; let currentTotalSize = selectedFiles.reduce((acc, curr) => acc + (curr.file?.size || 0), 0); let didProcessAnyFile = false; let localErrorMessage = null; for (const file of filesArray) { const isImage = file.type.startsWith('image/'); const isTxt = file.type === 'text/plain' || (file.name && file.name.toLowerCase().endsWith('.txt')); if (!isImage && !isTxt) { if (isFromPaste) console.log(`Pasted unsupported file: ${file.name} (${file.type})`); else localErrorMessage = `File "${file.name}" (type: ${file.type}) is not supported. Only images and .txt files are allowed.`; continue; } if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) { localErrorMessage = `File "${file.name}" is larger than ${MAX_FILE_SIZE_MB}MB.`; continue; } if (currentTotalSize + file.size > MAX_TOTAL_FILES_SIZE_MB * 1024 * 1024) { localErrorMessage = `Total file size cannot exceed ${MAX_TOTAL_FILES_SIZE_MB}MB.`; break; } filesToProcess.push(file); currentTotalSize += file.size; didProcessAnyFile = true; } if(localErrorMessage){ setChatError(localErrorMessage); } else { setChatError(null); } if (filesToProcess.length > 0) { const processedFileObjects = await Promise.all( filesToProcess.map(async (file) => { const id = Date.now().toString(36) + Math.random().toString(36).substring(2) + file.name; let apiData; if (file.type.startsWith('image/')) { const base64Data = await new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onloadend = () => resolve(reader.result.split(',')[1]); reader.onerror = (error) => reject(error); }); apiData = { mimeType: file.type, data: base64Data }; } else { const textContent = await file.text(); apiData = { textContent: textContent }; } return { id, file, name: file.name, type: file.type, apiData }; }) ); setSelectedFiles(prev => [...prev, ...processedFileObjects.filter(f => f)]); } return didProcessAnyFile; };
        
        const removeSelectedFile = (fileId) => { setSelectedFiles(prev => prev.filter(f => f.id !== fileId)); };

        const handleInputFromContentEditable = () => {
             setInputText(contentEditableRef.current?.innerText || ''); 
        };
        
        const handleSubmit = (e) => { 
            if(e) e.preventDefault(); 
            const currentText = contentEditableRef.current?.innerText.trim() || '';
            if (!currentText && selectedFiles.length === 0) return; 
            setUserHasScrolledUp(false); 
            setChatError(null); 
            onSendMessage(currentText, selectedFiles, isWebSearchEnabledState); 
            if(contentEditableRef.current) contentEditableRef.current.innerText = '';
            setInputText(''); 
            setSelectedFiles([]); 
            setShowToolsPopover(false);
        };

        const handleContentEditableKeyDown = (e) => { 
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault();
                if (!isSendButtonDisabled) { 
                    handleSubmit(e); 
                }
            }
        };

        const isAiCurrentlyProcessing = messages.some(m => m.role === 'model' && m.isLoading && !m.isError);
        const currentInputTextFromEditable = contentEditableRef.current?.innerText?.trim() || '';
        const isSendButtonDisabled = (!isAiCurrentlyProcessing && (isLoading || (currentInputTextFromEditable === '' && selectedFiles.length === 0)));
        
        const hasVisibleChatContent = messages.some( msg => (msg.text || msg.attachedFiles?.length > 0) && !(msg.role === 'system' && !msg.isError) );

        const lastMessage = messages[messages.length - 1];
        const userMessageForLastAi = messages.length > 1 ? messages[messages.length - 2] : null;
        const isLastMessageAiAndFinalized = lastMessage && lastMessage.role === 'model' && !lastMessage.isLoading && !isAiCurrentlyProcessing;
        const canRegenerateLastAiAsText = isLastMessageAiAndFinalized && userMessageForLastAi && userMessageForLastAi.role === 'user';

        const toggleToolsPopover = () => setShowToolsPopover(prev => !prev);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (popoverRef.current && !popoverRef.current.contains(event.target) &&
                    toolsButtonRef.current && !toolsButtonRef.current.contains(event.target)) {
                    setShowToolsPopover(false);
                }
            };
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }, []);

        const handleToggleWebSearch = (newValue) => {
            setIsWebSearchEnabledState(newValue);
        };
        
        const sendOrStopButtonBaseClasses = "w-9 h-9 flex items-center justify-center font-semibold rounded-full transition-all duration-150 ease-in-out transform active:animate-button-press focus:outline-none";
        let sendOrStopButtonDynamicClasses = "";

        if (isAiCurrentlyProcessing) { 
            sendOrStopButtonDynamicClasses = "bg-slate-200 hover:bg-slate-300 text-text-button-icon";
        } else if (isSendButtonDisabled) { 
            sendOrStopButtonDynamicClasses = "bg-slate-200 text-slate-400 cursor-not-allowed";
        } else { 
            sendOrStopButtonDynamicClasses = "bg-slate-200 hover:bg-slate-300 text-text-button-icon focus:ring-2 focus:ring-offset-1 focus:ring-focus-ring-color";
        }

        return (
          <div className="w-full h-full sm:max-w-2xl md:max-w-3xl lg:max-w-[780px] sm:mx-auto bg-white rounded-none sm:rounded-xl shadow-chat-window flex flex-col overflow-hidden sm:my-6 sm:max-h-[calc(100vh-3rem)]">
            <header className="p-4 border-b border-border-default bg-white flex items-center justify-between flex-shrink-0 shadow-header">
                <div className="flex items-center space-x-2">
                    <ReusableNewAiIcon className="w-8 h-8"/>
                    <div>
                        <h1 className="text-lg font-roboto font-semibold tracking-tight text-gradient-brand">AlphaGPT</h1>
                    </div>
                </div>
            </header>
            
            <div ref={chatContainerRef} className="flex-grow p-4 md:p-5 space-y-4 md:space-y-5 overflow-y-auto chat-messages-container relative bg-surface-chat-area">
                { !hasVisibleChatContent && !isLoading && ( 
                    <div className="absolute inset-0 flex flex-col items-center justify-center text-center pointer-events-none p-8 opacity-0 animate-fade-in-up" style={{animationDelay: '0.2s', animationFillMode: 'forwards'}}>
                        <p className="text-xl md:text-2xl font-[Outfit] font-semibold mb-2" style={{ color: '#536872' }}>Hello there!</p>
                        <p className="text-sm font-[Outfit] mt-1.5" style={{ color: '#536872' }}>I am AlphaGPT. You can ask me anything or share files to get started.</p>
                    </div> 
                )}
                {messages.map((msg) => (
                    <React.Fragment key={msg.id}>
                        {((msg.role === 'user' && (msg.text || msg.attachedFiles?.length > 0)) ||
                         (msg.role === 'model' && (!msg.isLoading || (msg.isLoading && msg.text))) || 
                         msg.role === 'system' ||
                         msg.isError) && (
                            <div> <ChatMessageItem message={msg} /> </div>
                        )}
                        {msg.role === 'model' && msg.isLoading && !msg.text && !msg.isError && ( 
                            <ThinkingAnimation isPotentiallySearching={msg.searchUsed && msg.loadingText === "Searching..."} />
                        )}
                    </React.Fragment>
                ))}
                {canRegenerateLastAiAsText && (
                    <div className={`flex mt-2 justify-start`}> 
                        <button 
                            onClick={() => { 
                                setChatError(null); 
                                onRegenerateLastTextMessage(lastMessage.id, isWebSearchEnabledState);
                            }} 
                            className="p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover transition-all duration-150 group" 
                            aria-label="Regenerate response" 
                            disabled={isLoading || isAiCurrentlyProcessing} 
                        > 
                            <i className="fas fa-arrows-rotate text-xs transform transition-transform duration-200 group-hover:rotate-[75deg]"></i> 
                        </button> 
                    </div> 
                )}
                <div ref={messagesEndRef} className="h-1" />
            </div>
            
            <form onSubmit={handleSubmit} className="bg-surface-chat-area flex-shrink-0">
              <div className="p-2 md:p-3">
                <div
                    className="flex flex-col bg-white border border-border-medium rounded-[19px] p-2 shadow-sm"
                    style={{ minHeight: '68px' }} 
                    onClick={(e) => {
                        if (contentEditableRef.current && 
                            !contentEditableRef.current.contains(e.target) && 
                            e.target.tagName !== 'BUTTON' && 
                            !e.target.closest('button') && 
                            (!popoverRef.current || !popoverRef.current.contains(e.target)) &&
                            (!toolsButtonRef.current || !toolsButtonRef.current.contains(e.target))
                           ) {
                           contentEditableRef.current.focus();
                        }
                    }}
                >
                  {selectedFiles.length > 0 && (
                    <div className="file-pill-container">
                        {selectedFiles.map(file => (
                            <div key={file.id} className="file-pill">
                                {file.type.startsWith('image/') ? <FileImageIcon className="file-pill-icon"/> : <FileTextIcon className="file-pill-icon"/> }
                                <span className="file-pill-name">{file.name}</span>
                                <button type="button" onClick={() => removeSelectedFile(file.id)} className="file-pill-remove">
                                    <i className="fas fa-times"></i>
                                </button>
                            </div>
                        ))}
                    </div>
                  )}

                  <div
                    ref={contentEditableRef}
                    contentEditable={!(isLoading || isAiCurrentlyProcessing)}
                    onInput={handleInputFromContentEditable}
                    onPaste={handlePaste}
                    onKeyDown={handleContentEditableKeyDown}
                    data-placeholder="Ask AlphaGPT..."
                    className="content-editable-input w-full flex-1 text-sm md:text-[15px] focus:outline-none resize-none overflow-y-auto relative" 
                    style={{ maxHeight: selectedFiles.length > 0 ? '80px' : '100px', minHeight: '24px' }}
                    suppressContentEditableWarning={true}
                  >
                  </div>

                  <div className="flex justify-between items-end w-full pt-1.5 mt-auto">
                    <div className="flex items-center space-x-1">
                        <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" multiple accept="image/*,.txt,text/plain" disabled={isLoading || isAiCurrentlyProcessing} />
                        
                        <button
                          type="button"
                          onClick={() => fileInputRef.current?.click()}
                          className="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-brand-primary transition-colors duration-150 disabled:opacity-60 flex-shrink-0 rounded-full hover:bg-gray-200 focus:outline-none"
                          aria-label="Attach file"
                          disabled={isLoading || isAiCurrentlyProcessing}
                        >
                          <i className="fas fa-plus text-lg"></i>
                        </button>
                        
                        <div className="relative">
                            <button
                                type="button"
                                ref={toolsButtonRef}
                                onClick={toggleToolsPopover}
                                className="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-brand-primary transition-colors duration-150 disabled:opacity-60 flex-shrink-0 rounded-full hover:bg-gray-200 focus:outline-none"
                                aria-label="Tools"
                                disabled={isLoading || isAiCurrentlyProcessing}
                            >
                                <i className="fas fa-sliders-h text-lg"></i>
                            </button>
                            {showToolsPopover && (
                                <div
                                    ref={popoverRef}
                                    className="absolute bottom-full mb-2 left-0 w-56 bg-white rounded-xl shadow-xl border border-border-default p-2 z-20 animate-scale-in-subtle origin-bottom-left"
                                >
                                    <div className="space-y-0.5">
                                        <button
                                            onClick={handleClearChatAction}
                                            className="w-full flex items-center space-x-2 px-2.5 py-1.5 text-xs text-text-secondary hover:bg-gray-100 rounded-md transition-colors duration-150 disabled:opacity-50"
                                            disabled={isLoading || messages.filter(m=>m.text || m.attachedFiles?.length > 0).length === 0}
                                        >
                                            <i className="fas fa-broom fa-fw text-xs text-text-subtle"></i>
                                            <span>Clear Chat</span>
                                        </button>
                                        <div className="flex items-center justify-between px-2.5 py-1.5 text-xs text-text-secondary rounded-md hover:bg-gray-100 cursor-pointer" onClick={() => handleToggleWebSearch(!isWebSearchEnabledState)}>
                                            <div className="flex items-center space-x-2">
                                                <i className="fas fa-globe fa-fw text-xs text-text-subtle"></i>
                                                <span>Web Search</span>
                                            </div>
                                            <button
                                                type="button"
                                                onClick={(e) => { e.stopPropagation(); handleToggleWebSearch(!isWebSearchEnabledState); }}
                                                className={`relative inline-flex items-center h-4 rounded-full w-8 transition-colors duration-200 ease-in-out focus:outline-none focus:ring-1 focus:ring-offset-0 focus:ring-blue-500 ${
                                                    !isWebSearchEnabledState && 'bg-gray-300'
                                                }`}
                                                style={isWebSearchEnabledState ? { backgroundColor: '#3399FF' } : {}}
                                                aria-pressed={isWebSearchEnabledState}
                                            >
                                                <span
                                                    className={`inline-block w-3 h-3 transform bg-white rounded-full transition-transform duration-200 ease-in-out ${
                                                        isWebSearchEnabledState ? 'translate-x-[18px]' : 'translate-x-0.5' 
                                                    }`}
                                                />
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    <button
                        type={isAiCurrentlyProcessing ? "button" : "submit"}
                        onClick={isAiCurrentlyProcessing ? onStopGeneration : undefined }
                        disabled={isSendButtonDisabled}
                        className={`${sendOrStopButtonBaseClasses} ${sendOrStopButtonDynamicClasses}`}
                        style={{ overflow: 'hidden' }} 
                        aria-label={isAiCurrentlyProcessing ? "Stop generation" : "Send message"}
                    >
                      {isAiCurrentlyProcessing ? (
                        <i className="fas fa-stop text-sm"></i>
                      ) : (
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-4 h-4">
                          <path d="M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z" />
                        </svg>
                      )}
                    </button>
                  </div>
                </div>
              </div>
            </form>
          </div>);
      };
      
      const App = () => { 
        const [chatMessages, setChatMessages] = useState([]); 
        const [isChatLoading, setIsChatLoading] = useState(false); 
        const [chatError, setChatError] = useState(null); 

        const isStoppingGenerationRef = useRef(false);
        
        const streamTextBuffer = useRef("");
        const streamSourcesBuffer = useRef([]); 
        
        useEffect(() => { 
            if (chatError) { 
                const errorId = Date.now() + '_sys_validation_err'; 
                setChatMessages(prev => { 
                    const lastMessage = prev[prev.length -1]; 
                    if(lastMessage && lastMessage.id.includes('_sys_validation_err') && lastMessage.text === chatError) return prev; 
                    return [...prev, {id: errorId, role: 'system', text: chatError, isError: true, timestamp: new Date()}]; 
                }); 
            }
        }, [chatError]); 

        const getGeminiHistory = (currentMessagesInternalFormat) => {
            const geminiMessages = currentMessagesInternalFormat
                .filter(msg => !(msg.role === 'system' || (msg.role === 'model' && msg.isLoading && !msg.text ) || msg.isError))
                .map(msg => {
                    const parts = [];
                    if (msg.role === 'model') {
                        if (msg.text) { 
                            parts.push({ text: msg.text });
                        }
                    } else if (msg.role === 'user') {
                        if (msg.text) parts.push({ text: msg.text });
                        if (msg.attachedFiles) {
                            msg.attachedFiles.forEach(file => {
                                if (file.type.startsWith('image/') && file.apiData?.mimeType && file.apiData?.data) {
                                    parts.push({ inlineData: { mimeType: file.apiData.mimeType, data: file.apiData.data } });
                                } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent) {
                                    parts.push({ text: `\n[Attached Text File: ${file.name}]\n${file.apiData.textContent}\n` });
                                }
                            });
                        }
                    }
                    return { role: msg.role, parts };
                }).filter(entry => entry.parts.length > 0);

            if (geminiMessages.length > 0 && geminiMessages[0].role === 'model') {
                const firstUserIndex = geminiMessages.findIndex(m => m.role === 'user');
                if (firstUserIndex === -1) return []; 
                const slicedHistory = geminiMessages.slice(firstUserIndex);
                if (slicedHistory.length > 1 && slicedHistory[0].role === slicedHistory[1].role) {
                    return [slicedHistory[0]];
                }
                return slicedHistory;
            }
            return geminiMessages;
        };
        useEffect(() => { if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") { setChatError("API Key is not configured. Please set it up."); } }, []); 
        
        const handleStopGeneration = useCallback(() => {
            isStoppingGenerationRef.current = true;
            setIsChatLoading(false); 

            setChatMessages(prevMessages => {
                let messageUpdated = false;
                const updatedMessages = prevMessages.map(msg => {
                    if (msg.role === 'model' && msg.isLoading) {
                        messageUpdated = true;
                        let newText = streamTextBuffer.current || msg.text || ""; 
                        const stopNotice = "*Generation stopped by user.*";
                        
                        if (!newText && !msg.text){ 
                            newText = stopNotice;
                        } else if (newText && !newText.includes(stopNotice)) {
                            const currentContent = newText;
                            if (currentContent.trim()) {
                                let processedContent = currentContent;
                                const isInCodeBlock = (processedContent.match(/```/g) || []).length % 2 !== 0;
                                if (isInCodeBlock) {
                                    processedContent += "\n```"; 
                                }
                                newText = processedContent + (processedContent.trim() ? "\n\n---\n" : "") + stopNotice;
                            } else {
                                newText = stopNotice;
                            }
                        } else if (!newText && msg.text && !msg.text.includes(stopNotice)){ 
                             newText = msg.text + (msg.text.trim() ? "\n\n---\n" : "") + stopNotice;
                        }
                        
                        return { ...msg, text: newText, isLoading: false, sources: streamSourcesBuffer.current.length > 0 ? [...streamSourcesBuffer.current] : msg.sources };
                    }
                    return msg;
                });
                return updatedMessages;
            });
        }, []); 

        const handleClearChat = useCallback(() => { if(!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY"){ setChatError("API Key is not configured. Please set it up to use the chat."); } else { setChatError(null); } setChatMessages([]); }, []);
        
        const mergeCitations = (existingSources, newSources) => {
            if (!newSources || newSources.length === 0) return existingSources;
            const existingUris = new Set((existingSources || []).map(s => s.uri));
            const uniqueNewSources = newSources.filter(src => src.uri && !existingUris.has(src.uri));
            return [...(existingSources || []), ...uniqueNewSources];
        };
        
        const _streamAiResponse = async (
            originalPromptParts, 
            targetAiMessageId, 
            historyForGeminiInit, 
            useSearchForThisTurn,
            currentLoadingText
        ) => {
            setIsChatLoading(true);
            streamTextBuffer.current = "";
            streamSourcesBuffer.current = []; 
            
            if (isStoppingGenerationRef.current) { 
                setIsChatLoading(false);
                return;
            }

            setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { 
                ...m, 
                isLoading: true, 
                isError: false, 
                searchUsed: useSearchForThisTurn,
                loadingText: currentLoadingText,
                text: "" 
            } : m));


            const performUiUpdateWithText = (isLoading = true) => { 
                if (!isStoppingGenerationRef.current || !isLoading) { 
                    setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { 
                        ...m, 
                        text: streamTextBuffer.current, 
                        isLoading: isLoading, 
                        isError: false, 
                        sources: streamSourcesBuffer.current.length > 0 ? [...streamSourcesBuffer.current] : null, 
                        searchUsed: useSearchForThisTurn,
                        loadingText: isLoading ? currentLoadingText : "" 
                    } : m));
                }
            };

            try {
                const modelConfig = { model: GEMINI_MAIN_MODEL, systemInstruction: getSystemInstruction() };
                if (useSearchForThisTurn) { 
                    modelConfig.tools = [{ googleSearch: {} }];
                }
                const chatModel = genAI.getGenerativeModel(modelConfig);
                const chatSession = chatModel.startChat({ history: historyForGeminiInit });
                
                if (isStoppingGenerationRef.current) {
                     setIsChatLoading(false);
                     return;
                }

                const result = await chatSession.sendMessageStream(originalPromptParts);
                let firstChunkReceived = false;

                for await (const chunk of result.stream) { 
                    if (isStoppingGenerationRef.current) break;
                    if(!firstChunkReceived){
                        if(chunk.text()?.trim()){
                             setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { ...m, loadingText: '' } : m));
                             firstChunkReceived = true;
                        }
                    }
                    
                    const rawChunkText = chunk.text();
                    let chunkTextForDisplay = "";

                    if (typeof rawChunkText === 'string') {
                        const lines = rawChunkText.split('\n');
                        const filteredLines = lines.filter(line => 
                            !line.trim().startsWith("tool_code") &&
                            !line.trim().startsWith("print(google_search.search")
                        );
                        if (filteredLines.length > 0 && filteredLines.some(line => line.trim() !== "" || lines.length === filteredLines.length )) {
                           chunkTextForDisplay = filteredLines.join('\n');
                        } else if (filteredLines.length === 0 && rawChunkText.trim() !== "") {
                            chunkTextForDisplay = ""; 
                        } else {
                            chunkTextForDisplay = rawChunkText; 
                        }
                    }
                    
                    let sourcesDeltaProcessed = false;
                    if (chunk.candidates && chunk.candidates[0]?.groundingMetadata?.groundingChunks) {
                        const sourcesDelta = chunk.candidates[0].groundingMetadata.groundingChunks
                          .filter(gc => gc.web && gc.web.uri)
                          .map(gc => ({ uri: gc.web.uri, title: gc.web.title || gc.web.uri }));
                        if (sourcesDelta && sourcesDelta.length > 0) {
                           streamSourcesBuffer.current = mergeCitations(streamSourcesBuffer.current, sourcesDelta);
                           sourcesDeltaProcessed = true;
                        }
                    }

                    if (chunkTextForDisplay.length > 0) {
                        const textParts = chunkTextForDisplay.split(/(\s+|\*+|`+|_|~|---|===|\n)/);
                        for (const part of textParts) {
                            if (isStoppingGenerationRef.current) break;
                            if (part.length === 0) continue;
                            streamTextBuffer.current += part;
                            performUiUpdateWithText(); 
                            await new Promise(resolve => setTimeout(resolve, Math.min(30, Math.max(5, part.length * 5))));
                        }
                    } else if (sourcesDeltaProcessed) {
                        if(streamTextBuffer.current) performUiUpdateWithText();
                    }
                    
                    if (isStoppingGenerationRef.current) break;
                }
                
                let finalText = streamTextBuffer.current;
                const stopNoticeStr = "*Generation stopped by user.*";
                if (isStoppingGenerationRef.current && !finalText.includes(stopNoticeStr)) {
                    const isInCodeBlock = (finalText.match(/```/g) || []).length % 2 !== 0;
                    if (isInCodeBlock) finalText += "\n```";
                    finalText += (finalText.trim() ? "\n\n---\n" : "") + stopNoticeStr;
                } else if (!isStoppingGenerationRef.current && !finalText.trim() && (!streamSourcesBuffer.current || streamSourcesBuffer.current.length === 0)) {
                    if (useSearchForThisTurn) { 
                        finalText = "I'm having a little trouble searching right now, or perhaps clear information isn't available on this topic. You could try regenerating the message, or ask your question a bit differently or more clearly. Thank you! üôè";
                    } else {
                        finalText = "I think I had some trouble understanding. Could you please clarify your question? ü§î";
                    }
                } else if (!isStoppingGenerationRef.current && !finalText.trim() && streamSourcesBuffer.current && streamSourcesBuffer.current.length > 0) {
                     finalText = "*Content is based on search results.*";
                }
                streamTextBuffer.current = finalText;
                performUiUpdateWithText(false);

            } catch (err) {
                console.error("AI stream error in _streamAiResponse:", err);
                let errorTextForUser = "A technical difficulty occurred while generating the response. Please try again later."; 
                if (err.message?.toLowerCase().includes("api key not valid")) errorTextForUser = "It seems there's an issue with the API key.";
                else if (err.message?.toLowerCase().includes("candidate was blocked")) errorTextForUser = "I cannot provide this response due to safety policies.";
                else if (err.message?.toLowerCase().includes("quota")) errorTextForUser = "The API usage limit has been reached.";
                
                streamTextBuffer.current = errorTextForUser;
                 setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { 
                    ...m, 
                    role: 'model', 
                    text: errorTextForUser, 
                    isLoading: false, 
                    isError: true, 
                    searchUsed: useSearchForThisTurn,
                    loadingText: ""
                } : m));
            } finally {
                setIsChatLoading(false);
            }
        };

        const handleSendChatMessage = useCallback(async (messageText, filesToSend, userWebSearchPreference) => {
            if (!messageText.trim() && filesToSend.length === 0) return;
            isStoppingGenerationRef.current = false; 
            setChatError(null);
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") {
                setChatError("API Key is not configured.");
                return;
            }
            
            const userMessageFiles = filesToSend.map(f => ({ id: f.id, name: f.name, type: f.type, apiData: f.apiData }));
            const newUserMessageForUi = { id: Date.now().toString() + '_user', role: 'user', text: messageText, timestamp: new Date(), attachedFiles: userMessageFiles };
            const aiMessageId = Date.now().toString() + '_model_resp';
            
            const needsSearch = userWebSearchPreference;
            const finalLoadingText = needsSearch ? "Searching..." : "Thinking...";
            
            const historyBeforeThisTurn = getGeminiHistory(chatMessages); 

            setChatMessages(prev => {
                const filteredPrev = prev.filter(m => !(m.role === 'system' && m.isError));
                const preliminaryAiPlaceholder = { 
                    id: aiMessageId, 
                    role: 'model', 
                    text: '', 
                    loadingText: finalLoadingText, 
                    timestamp: new Date(), 
                    isLoading: true, 
                    isError: false, 
                    sources: null, 
                    searchUsed: needsSearch, 
                };
                return [...filteredPrev, newUserMessageForUi, preliminaryAiPlaceholder];
            });

            const promptPartsForUserTurn = [];
            if (messageText.trim()) promptPartsForUserTurn.push({ text: messageText.trim() });
            filesToSend.forEach(file => {
                if (file.type.startsWith('image/') && file.apiData.mimeType && file.apiData.data) {
                    promptPartsForUserTurn.push({ inlineData: file.apiData });
                } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData.textContent) {
                    promptPartsForUserTurn.push({ text: `\n[Start of Text File: ${file.name}]\n${file.apiData.textContent}\n[End of Text File: ${file.name}]\n` });
                }
            });

            if (promptPartsForUserTurn.length > 0) {
                await _streamAiResponse(
                    promptPartsForUserTurn, 
                    aiMessageId, 
                    historyBeforeThisTurn, 
                    needsSearch, 
                    finalLoadingText
                );
            } else { 
                 setChatMessages(prev => prev.map(m => {
                    if (m.id === aiMessageId) {
                        return { ...m, role: 'model', text: "No content to send.", isLoading: false, isError: true, loadingText: "" };
                    }
                    return m;
                }).filter(msg => msg.id !== aiMessageId || msg.isError));
                setIsChatLoading(false);
            }
            
        }, [chatMessages]); 

        const handleRegenerateLastTextMessage = useCallback(async (aiMessageIdToRegenerate, userWebSearchPreference) => { 
            isStoppingGenerationRef.current = false; 
            setChatError(null);
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") {
                setChatError("API Key is not configured for regeneration.");
                return;
            }
            const originalAiMsgIndex = chatMessages.findIndex(m => m.id === aiMessageIdToRegenerate);
            if (originalAiMsgIndex <= 0 || chatMessages[originalAiMsgIndex-1].role !== 'user') {
                setChatError("Cannot regenerate: Preceding user prompt not found.");
                return;
            }
            
            const userPromptMsg = chatMessages[originalAiMsgIndex-1];
            const historyForGeminiInit = getGeminiHistory(chatMessages.slice(0, originalAiMsgIndex - 1));

            const needsSearch = userWebSearchPreference;
            const finalLoadingText = needsSearch ? "Searching..." : "Thinking...";

            const newAiPlaceholderId = Date.now().toString() + '_model_regen';
            
            setChatMessages(prev => {
                const chatHistoryForUiUpdate = prev.slice(0, originalAiMsgIndex);
                const preliminaryAiPlaceholder = { 
                    id: newAiPlaceholderId, 
                    role: 'model', 
                    text:'', 
                    loadingText: finalLoadingText,
                    isLoading:true, 
                    timestamp:new Date(), 
                    isError: false, 
                    sources: null, 
                    searchUsed: needsSearch, 
                };
                return [...chatHistoryForUiUpdate, preliminaryAiPlaceholder];
            });
            
            const promptPartsForRegen = [];
            if (userPromptMsg.text) promptPartsForRegen.push({ text: userPromptMsg.text });
            userPromptMsg.attachedFiles?.forEach(file => { 
                 if (file.type.startsWith('image/') && file.apiData.mimeType && file.apiData.data) {
                    promptPartsForRegen.push({ inlineData: file.apiData });
                 } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent) {
                    promptPartsForRegen.push({ text: `\n[Start of Text File: ${file.name}]\n${file.apiData.textContent}\n[End of Text File: ${file.name}]\n` });
                }
            });

            if (promptPartsForRegen.length > 0) {
                await _streamAiResponse(
                    promptPartsForRegen, 
                    newAiPlaceholderId, 
                    historyForGeminiInit, 
                    needsSearch, 
                    finalLoadingText
                );
            } else { 
                setChatMessages(prev => prev.map(m => {
                    if(m.id === newAiPlaceholderId) return {...m, isLoading: false, text: "No content found to regenerate.", isError: true, loadingText:""};
                    return m;
                }));
            }
        }, [chatMessages]); 


        return (
            <div className="h-full text-text-primary flex flex-col font-sans items-center justify-start sm:justify-center p-0">
                <ChatInterface 
                    messages={chatMessages} 
                    onSendMessage={handleSendChatMessage} 
                    isLoading={isChatLoading} 
                    onStopGeneration={handleStopGeneration} 
                    onRegenerateLastTextMessage={handleRegenerateLastTextMessage} 
                    onClearChat={handleClearChat} 
                    setChatError={setChatError} 
                />
            </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>
