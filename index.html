<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Oracle AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': 'rgb(var(--brand-primary) / <alpha-value>)',      
              'brand-secondary': 'rgb(var(--brand-secondary) / <alpha-value>)',  
              'surface-main': 'rgb(var(--surface-main) / <alpha-value>)',       
              'surface-card': 'rgb(var(--surface-card) / <alpha-value>)',      
              'surface-input': 'rgb(var(--surface-input) / <alpha-value>)',    
              'surface-accent': 'rgb(var(--surface-accent) / <alpha-value>)',    
              'surface-bubble-ai': 'rgb(var(--surface-bubble-ai) / <alpha-value>)',
              'surface-chat-area': 'rgb(var(--surface-chat-area) / <alpha-value>)',

              'text-primary': 'rgb(var(--text-primary) / <alpha-value>)',         
              'text-secondary': 'rgb(var(--text-secondary) / <alpha-value>)',           
              'text-on-primary': 'rgb(var(--text-on-primary) / <alpha-value>)',
              'text-subtle': 'rgb(var(--text-subtle) / <alpha-value>)',

              'border-default': 'rgb(var(--border-default) / <alpha-value>)',
              'border-light': 'rgb(var(--border-light) / <alpha-value>)',
              'border-medium': 'rgb(var(--border-medium) / <alpha-value>)',
              'interactive-hover': 'rgb(var(--interactive-hover) / <alpha-value>)',
              'interactive-focus-ring': 'rgb(var(--brand-primary) / 0.3)',


              'status-info': 'rgb(var(--status-info) / <alpha-value>)',
              'status-success': 'rgb(var(--status-success) / <alpha-value>)',
              'status-warning': 'rgb(var(--status-warning) / <alpha-value>)',
              'status-error': 'rgb(var(--status-error) / <alpha-value>)',
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              poppins: ['Poppins', 'sans-serif'],
            },
            animation: {
              'fade-in-up': 'fadeInUp 0.5s ease-out forwards',
              'scale-in-subtle': 'scaleInSubtle 0.35s ease-out forwards',
              'pulse-gentle': 'pulseGentle 2.8s infinite ease-in-out', 
              'typing-indicator': 'typingIndicator 1.2s infinite ease-in-out',
              'button-press': 'buttonPress 0.2s ease-out',
              'glow-soft': 'glowSoft 2.5s infinite alternate ease-in-out',
              'rippleOut': 'rippleOut 2.2s infinite ease-out', 
            },
            keyframes: {
              fadeInUp: {
                '0%': { opacity: '0', transform: 'translateY(10px)' },
                '100%': { opacity: '1', transform: 'translateY(0)' },
              },
              scaleInSubtle: {
                '0%': { opacity: '0.5', transform: 'scale(0.95)' },
                '100%': { opacity: '1', transform: 'scale(1)' },
              },
              pulseGentle: { 
                  '0%, 100%': { transform: 'scale(1)', opacity: '0.8' },
                  '50%': { transform: 'scale(1.02)', opacity: '1' },
              },
              typingIndicator: {
                '0%': { transform: 'translateY(0px)', opacity: '0.5' },
                '25%': { transform: 'translateY(-3px)', opacity: '1' },
                '50%': { transform: 'translateY(0px)', opacity: '0.5' },
                '100%': { transform: 'translateY(0px)', opacity: '0.5' },
              },
              buttonPress: {
                '0%': { transform: 'scale(1)' },
                '50%': { transform: 'scale(0.96)'},
                '100%': { transform: 'scale(1)' },
              },
              glowSoft: {
                '0%': { filter: 'drop-shadow(0 0 4px rgba(var(--brand-primary), 0.25)) drop-shadow(0 0 8px rgba(var(--brand-primary), 0.15))' },
                '100%': { filter: 'drop-shadow(0 0 8px rgba(var(--brand-primary), 0.35)) drop-shadow(0 0 16px rgba(var(--brand-primary), 0.2))' },
              },
              rippleOut: { 
                '0%': { transform: 'scale(0.7)', opacity: '0.4' },
                '70%': { opacity: '0.15' },
                '100%': { transform: 'scale(2.2)', opacity: '0' },
              }
            },
            boxShadow: {
                'interactive': '0 4px 12px 0 rgba(var(--brand-primary), 0.12)',
                'interactive-hover': '0 6px 16px 0 rgba(var(--brand-primary), 0.18)',
                'card': '0 8px 25px rgba(var(--text-primary), 0.05), 0 4px 10px rgba(var(--text-primary),0.03)',
                'header': '0 1px 3px rgba(var(--text-primary), 0.04), 0 1px 2px rgba(var(--text-primary), 0.02)',
                'input-focus': '0 0 0 3px rgb(var(--brand-primary) / 0.2)',
                'chat-window': '0 20px 60px -10px rgba(var(--text-primary), 0.1), 0 10px 30px -10px rgba(var(--text-primary),0.07)',
            }
          },
        },
      }
    </script>
    <style type="text/tailwindcss">
      @layer base {
        :root {
          --brand-primary: 20 184 166;      /* Tailwind Teal-500 */
          --brand-secondary: 13 148 136;    /* Tailwind Teal-600 */

          --surface-main: 247 247 248;     /* Custom very light gray, slightly warmer than slate-50 */
          --surface-card: 255 255 255;     /* White */
          --surface-chat-area: 249 250 251; /* Tailwind Gray-50, for messages background */
          --surface-input: 255 255 255;     /* White */
          --surface-accent: 240 253 250;   /* Tailwind Teal-50 */
          --surface-bubble-ai: 255 255 255; /* White (AI messages on white, with border) */

          --text-primary: 23 37 52;       /* Custom Dark Blue/Gray - Slate 800: 30 41 59 */
          --text-secondary: 71 85 105;    /* Tailwind Slate-600 */
          --text-subtle: 100 116 139;      /* Tailwind Slate-500 */
          --text-on-primary: 255 255 255;   /* White */

          --border-default: 226 232 240;   /* Tailwind Slate-200 */
          --border-light: 241 245 249;     /* Tailwind Slate-100 */
          --border-medium: 203 213 225;    /* Tailwind Slate-300 */
          
          --interactive-hover: 204 251 241; /* Tailwind Teal-100 */

          --status-info: 59 130 246;      /* Tailwind Blue-500 */
          --status-success: 22 163 74;    /* Tailwind Green-600 */
          --status-warning: 245 158 11;   /* Tailwind Yellow-500 */
          --status-error: 220 38 38;      /* Tailwind Red-600 */
        }
        html, body, #root { @apply h-full overflow-hidden; }
        body { @apply font-sans bg-surface-main text-text-primary m-0; }
        ::selection { @apply bg-brand-primary/20 text-brand-secondary; }
      }
      @layer components {
        .markdown-content p { @apply mb-3 last:mb-0; }
        .markdown-content ul, .markdown-content ol { @apply list-inside mb-3 pl-4; }
        .markdown-content ul { @apply list-disc; } .markdown-content ul ul { @apply list-[circle] ml-4;}
        .markdown-content ol { @apply list-decimal; } .markdown-content ol ol { @apply list-[lower-alpha] ml-4;}
        .markdown-content li { @apply mb-1.5; }
        .markdown-content strong, .markdown-content b { @apply font-semibold text-text-primary; }
        .markdown-content em, .markdown-content i { @apply italic text-text-secondary; }
        .markdown-content code { @apply bg-slate-100 text-slate-700 text-xs px-1.5 py-0.5 rounded-md font-mono shadow-sm border border-slate-200; }
        .markdown-content pre { @apply bg-slate-800 text-slate-100 p-4 rounded-lg shadow-md overflow-x-auto text-sm my-4 font-mono relative; }
        .markdown-content pre code { @apply bg-transparent text-slate-100 p-0 shadow-none border-none; }
        .markdown-content a { @apply text-brand-primary hover:text-brand-secondary underline decoration-brand-primary/50 hover:decoration-brand-secondary transition-colors; }
        .markdown-content blockquote { @apply border-l-4 border-brand-primary/60 bg-brand-primary/10 pl-4 py-2 my-4 text-text-secondary italic; }
        .markdown-content h1, .markdown-content h2, .markdown-content h3,
        .markdown-content h4, .markdown-content h5, .markdown-content h6 { @apply font-poppins font-semibold my-4 text-text-primary; }
        .markdown-content h1 { @apply text-xl leading-tight; } .markdown-content h2 { @apply text-lg leading-tight; } .markdown-content h3 { @apply text-base leading-tight; }
        .markdown-content hr { @apply my-6 border-border-default; }
        
        .markdown-content table { @apply w-full my-4 border-collapse text-sm shadow-sm rounded-lg overflow-hidden; }
        .markdown-content th, .markdown-content td { @apply border border-border-default p-2.5 text-left; }
        .markdown-content th { @apply bg-surface-accent font-semibold text-text-primary; }
        .markdown-content td { @apply text-text-secondary; }
        .markdown-content tbody tr:nth-child(even) { @apply bg-slate-50/50; }
        .markdown-content tbody tr:hover { @apply bg-interactive-hover/50; }

        .chat-messages-container::-webkit-scrollbar { @apply w-1.5; }
        .chat-messages-container::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; }
        .chat-messages-container::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400 transition-colors; }
        .chat-messages-container { scrollbar-width: thin; scrollbar-color: theme('colors.slate.300') theme('colors.slate.100'); }
        
        textarea.auto-resize {
            min-height: 52px; 
            max-height: 180px; 
        }
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/generative-ai@^0.11.3",
          "react": "https://esm.sh/react@^18.2.0",
          "react/": "https://esm.sh/react@^18.2.0/",
          "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
          "marked": "https://esm.sh/marked@^12.0.2"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenerativeAI } from '@google/genai';
      import { marked } from 'marked';

      marked.setOptions({ gfm: true, breaks: true, smartypants: true });

      const GEMINI_MODEL_NAME = 'gemini-2.5-flash-preview-05-20'; // DO NOT CHANGE
      const API_KEY = "AIzaSyDSF270Y1VJf1fe4G8ZAuw7bOITbAlal74"; // DO NOT CHANGE
      const CHAT_STORAGE_KEY = 'oracleAIChatMessages_v11_mobileEnter'; // Updated key
      const MAX_FILE_SIZE_MB = 5;
      const MAX_TOTAL_FILES_SIZE_MB = 20;

      if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") console.error(" ERROR: Gemini API Key is not set.");
      const genAI = new GoogleGenerativeAI(API_KEY);
      let activeChatSession = null;

      function getSystemInstruction() {
        return `You are a friendly AI assistant.
Your responses MUST be ONLY in Roman Urdu.
Do not use English words or sentences, unless it's a proper noun that doesn't have a common Roman Urdu equivalent or a very common loanword used in Roman Urdu.
You MUST use Markdown for formatting your Roman Urdu responses, including tables when appropriate for comparisons or structured data.
Keep your answers concise and helpful.
User may attach files:
- If an image is provided, you can describe it or answer questions about it.
- If a .txt file is provided, its text content will be given to you.
Jab user aap se aapka naam pooche, to aapko kehna hai "Mera naam **Oracle** hai, aur main aapki madad ke liye yahan hoon."
Jab user pooche ke aapko kisne banaya hai, to aapko kehna hai "Mujhe **Azeem** ne banaya hai."
Jab user pooche ke Azeem kon hai, ya "who is he" (Azeem ke baray mein), to aapko kehna hai "Mere paas unke baray mein zyada tafseeli maloomat nahi hain, lekin woh mere developer hain."`;
      }
      
      const initializeChat = (history = []) => { 
        const systemInstruction = getSystemInstruction();
        if (history.length > 0 && history[0].role !== 'user') {
            console.warn("Attempting to initialize chat with history that does not start with 'user' role. Resetting history for safety.", JSON.stringify(history, null, 2));
            history = []; 
        }
        const chatModel = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME, systemInstruction });
        activeChatSession = chatModel.startChat({ history }); 
      };

      const sendMessageToChatStream = async (messageParts) => { 
        if (!activeChatSession) { throw new Error("Chat session is not initialized. This should not happen if initializeChat was called correctly."); }
        try {
          const result = await activeChatSession.sendMessageStream(messageParts); 
          return result.stream;
        } catch (error) {
          console.error("Error sending chat message stream:", error, "Parts sent:", messageParts, "Session history before send:", activeChatSession?.history);
          activeChatSession = null; 
          if (error.message?.toLowerCase().includes("api key not valid")) throw new Error("Invalid API Key.");
          if (error.message?.toLowerCase().includes("candidate was blocked")) throw new Error("Mawad block kar diya gaya.");
          if (error.message?.toLowerCase().includes("first content should be with role 'user'")) {
            throw new Error("[GoogleGenerativeAI Error]: First content should be with role 'user', got model. Check history sequence.");
          }
          throw new Error(error.message || "An unknown error occurred sending message.");
        }
      };

      const HeaderBrandIcon = (props) => (
        <div className={`flex items-center justify-center text-brand-primary w-8 h-8 ${props.className}`}>
            <i className="fa-solid fa-atom text-2xl"></i>
        </div>
      );

      const EmptyStateLogo = (props) => (
        <div className={`relative flex items-center justify-center ${props.className} animate-glow-soft`}>
          <div 
            className="absolute w-full h-full rounded-full bg-brand-primary/5 animate-rippleOut"
            style={{ animationDelay: '0s' }} 
          ></div>
          <div 
            className="absolute w-full h-full rounded-full bg-brand-primary/10 animate-rippleOut" 
            style={{ animationDelay: '1.1s' }} 
          ></div>
          <i 
            className="fa-solid fa-atom text-brand-primary relative z-10" 
            style={{ fontSize: 'clamp(3rem, 15vw, 4.5rem)' }}
          ></i>
        </div>
      );
      
      const AiAvatarIcon = (props) => (
        <div className={`flex-shrink-0 w-9 h-9 md:w-10 md:h-10 rounded-full bg-gradient-to-br from-slate-100 to-slate-200 text-brand-primary flex items-center justify-center shadow-sm p-0.5 ${props.className}`}>
            <i className="fa-solid fa-atom text-xl"></i>
        </div>
      );

      const UserAvatarIcon = (props) => (
         <div className={`flex-shrink-0 w-9 h-9 md:w-10 md:h-10 rounded-full bg-gradient-to-br from-brand-primary to-brand-secondary text-text-on-primary flex items-center justify-center shadow-sm ${props.className}`}>
            <i className="fa-solid fa-user text-base"></i>
        </div>
      );
      
      const COPY_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" /></svg>`;
      const CHECK_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;
      
      const FileTextIcon = (props) => (<i className={`fa-solid fa-file-lines ${props.className || ''}`}></i>);
      const FileImageIcon = (props) => (<i className={`fa-solid fa-file-image ${props.className || ''}`}></i>);

      const ChatMessageItem = ({ message }) => { 
        const isUser = message.role === 'user'; 
        const isSystem = message.role === 'system'; 
        const contentRef = useRef(null); 
        const showAvatarAnimation = !isUser && message.isLoading;

        useEffect(() => { 
          if (message.role === 'model' && contentRef.current) { 
            const preElements = contentRef.current.querySelectorAll('pre'); 
            preElements.forEach(preEl => { 
              if (preEl.querySelector('.code-copy-button')) return;
              const button = document.createElement('button'); 
              button.innerHTML = COPY_ICON_SVG; 
              button.classList.add('code-copy-button', 'absolute', 'top-2.5', 'right-2.5', 'p-1.5', 'bg-slate-700', 'hover:bg-slate-600', 'text-slate-300', 'hover:text-slate-100', 'rounded-md', 'transition-colors', 'duration-150', 'opacity-60', 'hover:opacity-100', 'focus:opacity-100', 'focus:ring-2', 'focus:ring-teal-400', 'focus:outline-none'); 
              button.setAttribute('aria-label', 'Copy code'); 
              preEl.appendChild(button); 
              button.onclick = () => {  
                const codeElement = preEl.querySelector('code'); 
                if (codeElement) { 
                  navigator.clipboard.writeText(codeElement.textContent || '').then(() => { 
                    button.innerHTML = CHECK_ICON_SVG; 
                    button.classList.add('text-emerald-400');  
                    setTimeout(() => { 
                      button.innerHTML = COPY_ICON_SVG; 
                      button.classList.remove('text-emerald-400'); 
                    }, 2000); 
                  }).catch(err => console.error('Failed to copy: ', err)); 
                }
              }; 
            }); 
          } 
        }, [message.text, message.role, message.isLoading]);

        if (isSystem) { 
          return ( 
            <div className="flex justify-center my-4 animate-fade-in-up opacity-0" style={{animationFillMode: 'forwards'}}> 
              <div className="px-4 py-2 text-xs text-text-subtle bg-surface-accent border border-border-light rounded-full shadow-sm italic"> 
                {message.text} 
              </div> 
            </div> 
          );
        }

        return (
          <div className={`flex items-end space-x-2.5 md:space-x-3 ${isUser ? 'justify-end' : ''} animate-fade-in-up opacity-0`} style={{animationFillMode: 'forwards'}}>
            {!isUser && ( <AiAvatarIcon className={`${showAvatarAnimation ? 'animate-pulse-gentle' : ''}`} /> )}
            <div className={`px-4 py-3 md:px-4 md:py-3 shadow-card max-w-[80%] sm:max-w-[75%] ${ isUser ? 'bg-gradient-to-br from-brand-primary to-brand-secondary text-text-on-primary rounded-2xl rounded-br-md' : 'bg-surface-bubble-ai text-text-primary rounded-2xl rounded-bl-md border border-border-default' }`} >
              {isUser && message.attachedFiles && message.attachedFiles.length > 0 && (
                <div className={`grid gap-2.5 ${message.text ? 'mb-2.5' : ''} ${message.attachedFiles.length > 1 ? 'grid-cols-2' : 'grid-cols-1'}`}>
                  {message.attachedFiles.map(file => {
                    if (file.type?.startsWith('image/') && file.apiData?.data && file.apiData?.mimeType) {
                      const imageSrc = `data:${file.apiData.mimeType};base64,${file.apiData.data}`;
                      return (
                        <div key={file.id || file.name}
                             className="rounded-lg overflow-hidden border border-teal-200 bg-white shadow-sm group relative max-w-full w-full sm:w-auto sm:max-w-[180px]">
                          <img
                            src={imageSrc}
                            alt={file.name || 'image preview'}
                            className="block w-full max-h-40 object-contain"
                          />
                           <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center p-1">
                             <p className="text-[10px] text-white text-center truncate font-medium">{file.name}</p>
                           </div>
                        </div>
                      );
                    } else { 
                      return (
                        <div key={file.id || file.name} className="bg-teal-500 p-2.5 rounded-lg text-xs flex items-center space-x-2 max-w-full w-fit shadow">
                          {file.type?.startsWith('image/') ? <FileImageIcon className="text-teal-100 text-base" /> : <FileTextIcon className="text-teal-100 text-base" />}
                          <span className="truncate max-w-[120px] sm:max-w-[150px] text-white font-medium">{file.name}{file.type?.startsWith('image/') ? " (preview unavailable)" : ""}</span>
                        </div>
                      );
                    }
                  })}
                </div>
              )}
              {message.text && (isUser ? <p className="text-sm md:text-base whitespace-pre-wrap break-words">{message.text}</p> : <div ref={contentRef} className="text-sm md:text-base markdown-content break-words" dangerouslySetInnerHTML={{ __html: marked.parse(message.text || '') }} /> )}
              {showAvatarAnimation && ( 
                <div className="flex items-end space-x-1.5 mt-2.5">
                  <span className="w-2 h-2 bg-brand-primary rounded-full animate-typing-indicator" style={{ animationDelay: '0s' }}></span>
                  <span className="w-2 h-2 bg-brand-primary rounded-full animate-typing-indicator" style={{ animationDelay: '0.15s' }}></span>
                  <span className="w-2 h-2 bg-brand-primary rounded-full animate-typing-indicator" style={{ animationDelay: '0.3s' }}></span>
                </div>
              )}
            </div>
            {isUser && ( <UserAvatarIcon /> )}
          </div>);
      };

      const ChatInterface = ({ messages, onSendMessage, isLoading, error, onStopGeneration, onRegenerate, onClearChat, setChatError }) => {
        const [inputText, setInputText] = useState('');
        const [selectedFiles, setSelectedFiles] = useState([]);
        const fileInputRef = useRef(null);
        const messagesEndRef = useRef(null);
        const textareaRef = useRef(null);
        const [isMobileView, setIsMobileView] = useState(false);

        useEffect(() => {
          const checkMobileView = () => setIsMobileView(window.innerWidth < 768);
          window.addEventListener('resize', checkMobileView);
          checkMobileView(); // Initial check
          return () => window.removeEventListener('resize', checkMobileView);
        }, []);

        useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages]);

        useEffect(() => {
            const ta = textareaRef.current;
            if (ta) {
                ta.style.height = 'auto';
                const scrollHeight = ta.scrollHeight;
                const maxHeight = parseInt(getComputedStyle(ta).maxHeight, 10) || 180;
                ta.style.height = `${Math.min(scrollHeight, maxHeight)}px`;
            }
        }, [inputText]);

        const handleFileChange = async (event) => { 
            const files = Array.from(event.target.files);
            processAndSetFiles(files);
            if (fileInputRef.current) fileInputRef.current.value = ""; 
        };

        const handlePaste = async (event) => { 
            const pastedFiles = Array.from(event.clipboardData.files);
            if (pastedFiles.length > 0) {
                const processedSomething = await processAndSetFiles(pastedFiles, true);
                if (processedSomething) event.preventDefault(); 
            }
        };
        
        const processAndSetFiles = async (filesArray, isFromPaste = false) => {
            if (!filesArray.length) return false;
            let filesToProcess = [];
            let currentTotalSize = selectedFiles.reduce((acc, curr) => acc + (curr.file?.size || 0), 0);
            let didProcessAnyFile = false;

            for (const file of filesArray) {
                const isImage = file.type.startsWith('image/');
                const isTxt = file.type === 'text/plain' || (file.name && file.name.toLowerCase().endsWith('.txt'));
                if (!isImage && !isTxt) {
                    if (isFromPaste) console.log(`Pasted unsupported file: ${file.name} (${file.type})`);
                    else setChatError(`File "${file.name}" (type: ${file.type}) support nahi hai.`);
                    continue;
                }
                if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) { setChatError(`File "${file.name}" ${MAX_FILE_SIZE_MB}MB se bari hai.`); continue; }
                if (currentTotalSize + file.size > MAX_TOTAL_FILES_SIZE_MB * 1024 * 1024) { setChatError(`Total files ka size ${MAX_TOTAL_FILES_SIZE_MB}MB se ziada nahi ho sakta.`); break; }
                filesToProcess.push(file); currentTotalSize += file.size; didProcessAnyFile = true;
            }
            if (filesToProcess.length > 0) {
                const processedFileObjects = await Promise.all(
                  filesToProcess.map(async (file) => {
                    const id = Date.now().toString(36) + Math.random().toString(36).substring(2) + file.name;
                    let apiData;
                    if (file.type.startsWith('image/')) {
                      const base64Data = await new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onloadend = () => resolve(reader.result.split(',')[1]); reader.onerror = (error) => reject(error); });
                      apiData = { mimeType: file.type, data: base64Data };
                    } else { const textContent = await file.text(); apiData = { textContent: textContent }; }
                    return { id, file, name: file.name, type: file.type, apiData };
                  })
                );
                setSelectedFiles(prev => [...prev, ...processedFileObjects.filter(f => f)]);
            }
            return didProcessAnyFile;
        };
        
        const removeSelectedFile = (fileId) => { setSelectedFiles(prev => prev.filter(f => f.id !== fileId)); };
        
        const handleSubmit = (e) => { 
          if(e) e.preventDefault(); 
          if (!inputText.trim() && selectedFiles.length === 0) return; 
          onSendMessage(inputText, selectedFiles); 
          setInputText(''); 
          setSelectedFiles([]); 
        };
        
        const handleTextareaKeyDown = (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            if (isMobileView) {
              // On mobile, Enter (without Shift) just creates a newline.
              // Do not prevent default, do not submit.
              return;
            } else {
              // On desktop, Enter (without Shift) submits if not disabled.
              if (!isSendButtonDisabled) {
                handleSubmit(e); // Pass event to handle its preventDefault
              } else {
                e.preventDefault(); // If send disabled on desktop, still prevent newline.
              }
            }
          }
        };

        const isAiCurrentlyStreaming = messages.some(m => m.role === 'model' && m.isLoading);
        const isSendButtonDisabled = (!isAiCurrentlyStreaming && (isLoading || (inputText.trim() === '' && selectedFiles.length === 0)));
        
        const canRegenerateLastAi = messages.length > 0 && 
          messages[messages.length - 1].role === 'model' && !messages[messages.length - 1].isLoading && !isAiCurrentlyStreaming && 
          messages.length > 1 && messages[messages.length - 2].role === 'user' && 
          !(messages[messages.length - 2].attachedFiles?.some(f => f.type?.startsWith('image/')));

        return (
          <div className="w-full h-full sm:max-w-2xl md:max-w-3xl lg:max-w-[780px] sm:mx-auto bg-surface-card rounded-none sm:rounded-xl shadow-chat-window flex flex-col overflow-hidden sm:my-6 sm:max-h-[calc(100vh-3rem)]">
            <header className="p-4 border-b border-border-light bg-surface-card flex items-center justify-between flex-shrink-0 shadow-header"> 
              <div className="flex items-center space-x-3"> 
                <HeaderBrandIcon /> 
                <div>
                  <h1 className="text-lg font-poppins font-semibold text-text-primary tracking-tight">Oracle AI</h1>
                  <p className="text-xs text-text-secondary -mt-0.5">Modern Chat Experience</p>
                </div>
              </div> 
              <button onClick={onClearChat} 
                      className="text-sm font-medium text-text-secondary hover:text-status-error px-3 py-1.5 rounded-lg hover:bg-red-500/10 transition-colors duration-150 disabled:opacity-50 flex items-center space-x-1.5 group" 
                      aria-label="Clear chat" 
                      disabled={isLoading || messages.filter(m=>m.text || m.attachedFiles?.length > 0).length === 0}> 
                <i className="fas fa-broom fa-fw text-sm transition-transform group-hover:scale-110"></i>
                <span className="hidden sm:inline">Clear</span> 
              </button> 
            </header>
            
            <div className="flex-grow p-4 md:p-5 space-y-4 md:space-y-5 overflow-y-auto chat-messages-container relative bg-surface-chat-area"> 
              {messages.filter(m=>m.text || m.attachedFiles?.length > 0).length === 0 && !isLoading && !error && ( 
                <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none p-8 text-center opacity-0 animate-fade-in-up" style={{animationDelay: '0.2s', animationFillMode: 'forwards'}}> 
                  <EmptyStateLogo className="w-28 h-28 md:w-32 md:h-32 mb-6" /> 
                  <p className="text-xl md:text-2xl font-poppins font-semibold text-text-secondary">Assalam-o-Alaikum!</p> 
                  <p className="text-sm text-text-subtle mt-1.5">Mein Oracle AI hoon. Aap mujhse kuch bhi pooch sakte hain ya files share kar sakte hain.</p> 
                </div> 
              )} 
              {messages.map((msg) => ( 
                (msg.text || msg.attachedFiles?.length > 0 || (msg.role === 'model' && msg.isLoading)) && 
                <div key={msg.id}> 
                  <ChatMessageItem message={msg} /> 
                  {msg.id === messages[messages.length - 1]?.id && canRegenerateLastAi && ( 
                    <div className={`flex mt-2 ${msg.role === 'user' ? 'justify-end pr-12 md:pr-14' : 'justify-start pl-12 md:pl-14'}`}> 
                      <button 
                        onClick={() => onRegenerate(msg.id)} 
                        className="p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover transition-all duration-150 group" 
                        aria-label="Regenerate response" 
                        disabled={isLoading} > 
                        <i className="fas fa-arrows-rotate text-xs transform transition-transform duration-200 group-hover:rotate-[75deg]"></i> 
                      </button> 
                    </div> 
                  )} 
                </div> 
              ))} 
              <div ref={messagesEndRef} className="h-1" /> 
            </div>

            {error && ( 
              <div className="p-3 md:p-4 border-t border-red-300 bg-red-50 text-red-700 text-sm flex-shrink-0 shadow-inner flex items-start space-x-2.5">
                <i className="fas fa-exclamation-triangle mt-0.5 text-red-600"></i>
                <span><strong>Error:</strong> {error}</span>
              </div> 
            )}
            
            {selectedFiles.length > 0 && ( 
              <div className="p-3 border-t border-border-light bg-surface-input flex flex-wrap gap-2 items-center overflow-x-auto flex-shrink-0"> 
                {selectedFiles.map(file => ( 
                  <div key={file.id} className="bg-surface-accent border border-border-light text-xs pl-2.5 pr-1.5 py-1 rounded-full flex items-center shadow-sm hover:shadow-md transition-shadow duration-150 flex-shrink-0 animate-scale-in-subtle"> 
                    {file.type.startsWith('image/') ? <FileImageIcon className="text-brand-primary text-sm mr-1.5"/> : <FileTextIcon className="text-brand-primary text-sm mr-1.5"/> } 
                    <span className="truncate max-w-[90px] sm:max-w-[120px] text-text-secondary font-medium">{file.name}</span> 
                    <button onClick={() => removeSelectedFile(file.id)} className="ml-2 text-slate-400 hover:text-status-error p-0.5 rounded-full hover:bg-red-500/10 transition-colors"> 
                      <i className="fas fa-times text-xs"></i> 
                    </button> 
                  </div> 
                ))} 
              </div> 
            )}

            <form onSubmit={handleSubmit} className="p-3 md:p-4 border-t border-border-light bg-surface-input flex items-end space-x-2 md:space-x-3 flex-shrink-0"> 
              <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" multiple accept="image/*,.txt,text/plain" disabled={isLoading && !isAiCurrentlyStreaming} /> 
              <button type="button" onClick={() => fileInputRef.current?.click()} 
                      className="p-3 rounded-xl text-text-secondary hover:text-brand-primary hover:bg-interactive-hover transition-colors duration-150 disabled:opacity-60 disabled:cursor-not-allowed flex-shrink-0" 
                      aria-label="Attach files" 
                      disabled={isLoading && !isAiCurrentlyStreaming}> 
                <i className="fas fa-paperclip text-lg"></i> 
              </button> 
              <textarea 
                ref={textareaRef}
                value={inputText} 
                onChange={(e) => setInputText(e.target.value)} 
                onPaste={handlePaste} 
                onKeyDown={handleTextareaKeyDown}
                placeholder="Aap yahan likh sakte hain..." 
                rows={1} 
                className="flex-grow px-4 py-3 text-sm md:text-base border border-border-medium rounded-xl bg-white shadow-sm focus:outline-none focus:ring-2 focus:ring-interactive-focus-ring focus:border-brand-primary resize-none placeholder-text-subtle auto-resize transition-shadow focus:shadow-md" 
                disabled={isLoading && !isAiCurrentlyStreaming}
              /> 
              <button type={isAiCurrentlyStreaming ? "button" : "submit"} 
                      onClick={isAiCurrentlyStreaming ? onStopGeneration : undefined } // Form onSubmit will handle for type="submit"
                      disabled={isAiCurrentlyStreaming ? false : isSendButtonDisabled} 
                      className={`font-semibold w-11 h-11 rounded-xl shadow-interactive flex items-center justify-center transition-all duration-200 ease-in-out transform hover:shadow-interactive-hover active:animate-button-press flex-shrink-0
                                  ${isAiCurrentlyStreaming 
                                    ? 'bg-gradient-to-br from-red-400 to-rose-500 hover:from-red-500 hover:to-rose-600 text-white'
                                    : (isSendButtonDisabled 
                                        ? 'bg-slate-300 text-slate-500 cursor-not-allowed shadow-none' 
                                        : 'bg-gradient-to-br from-brand-primary to-brand-secondary hover:from-brand-primary hover:to-teal-700 text-white hover:scale-105'
                                      ) 
                                  }
                                `} 
                      aria-label={isAiCurrentlyStreaming ? "Stop generation" : "Send message"}> 
                {isAiCurrentlyStreaming ? <i className="fas fa-stop text-xl"></i> : <i className="fas fa-paper-plane text-lg"></i>} 
              </button> 
            </form>
          </div>);
      };

      const App = () => {
        const [chatMessages, setChatMessages] = useState(() => { try { const saved = localStorage.getItem(CHAT_STORAGE_KEY); if(saved) { const p = JSON.parse(saved); return Array.isArray(p) ? p.map(m=>({...m, timestamp: m.timestamp ? new Date(m.timestamp) : new Date()})) : []; } } catch(e){ console.error("LS load error:", e); localStorage.removeItem(CHAT_STORAGE_KEY); } return []; });
        const [isChatLoading, setIsChatLoading] = useState(false);
        const [chatError, setChatError] = useState(null);
        const isStoppingGenerationRef = useRef(false);

        useEffect(() => { try { localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chatMessages)); } catch(e){ console.error("LS save error:", e);}}, [chatMessages]);
        
        const getGeminiHistory = (currentMessagesInternalFormat) => {
          const geminiMessages = currentMessagesInternalFormat 
            .filter(msg => !((msg.role === 'system') || (msg.role === 'model' && msg.isLoading))) 
            .map(msg => {
                const parts = [];
                if (msg.text) parts.push({ text: msg.text });
                if (msg.role === 'user' && msg.attachedFiles) {
                    msg.attachedFiles.forEach(file => {
                        if (file.type.startsWith('image/') && file.apiData?.mimeType && file.apiData?.data) {
                            parts.push({ inlineData: { mimeType: file.apiData.mimeType, data: file.apiData.data } });
                        } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent) {
                            parts.push({ text: `\n[Attached Text File: ${file.name}]\n${file.apiData.textContent}\n` });
                        }
                    });
                }
                return { role: msg.role, parts };
            }).filter(entry => entry.parts.length > 0);

          if (geminiMessages.length > 0 && geminiMessages[0].role === 'model') { 
            const firstUserIndex = geminiMessages.findIndex(m => m.role === 'user');
            if (firstUserIndex === -1) { return []; } 
            const slicedHistory = geminiMessages.slice(firstUserIndex);
            if (slicedHistory.length > 1 && slicedHistory[0].role === slicedHistory[1].role) {
              return [slicedHistory[0]]; 
            }
            return slicedHistory;
          }
          return geminiMessages; 
        };

        useEffect(() => { 
          if (API_KEY && API_KEY !== "YOUR_GEMINI_API_KEY") { 
            const initialGeminiHistory = getGeminiHistory(chatMessages);
            initializeChat(initialGeminiHistory); 
            setChatError(null); 
          } else { 
            setChatError("Gemini API Key is not configured."); 
            if (chatMessages.length === 0) {
              setChatMessages([{id: Date.now().toString()+'_sys_init', role:'system', text:"Welcome! Please configure your Gemini API Key to begin.", timestamp:new Date()}]);
            }
          } 
        }, []); 

        const handleStopGeneration = useCallback(() => { 
          isStoppingGenerationRef.current = true; 
          setChatMessages(prev => prev.map(m => m.isLoading && m.role === 'model' ? {...m, isLoading:false, text: (m.text || "") + "\n\n---\n*Generation stopped by user.*"} : m)); 
          setIsChatLoading(false); 
        }, []);

        const handleClearChat = useCallback(() => { 
          let initMsg = []; 
          if(!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY"){ 
            initMsg=[{id:Date.now().toString()+'_sys_clr', role:'system', text:"Gemini API Key not configured. Please set it up to use the chat.", timestamp:new Date()}]; 
            setChatError("Gemini API Key not configured."); 
          } else { 
            initializeChat([]); 
            setChatError(null); 
          } 
          setChatMessages(initMsg); 
        }, []);
        
        const _streamAiResponse = async (promptPartsForCurrentTurn, targetAiMessageId, historyForGeminiInit) => { 
            isStoppingGenerationRef.current = false; 
            setIsChatLoading(true); 
            setChatError(null); 
            let displayedAiText = "";
            try {
                initializeChat(historyForGeminiInit);
                
                const stream = await sendMessageToChatStream(promptPartsForCurrentTurn);
                for await (const chunk of stream) { 
                    if (isStoppingGenerationRef.current) break; 
                    const chunkContent = chunk.text(); 
                    if (typeof chunkContent !== 'string') continue; 
                    const segments = chunkContent.match(/.{1,4}|\s+/g) || [chunkContent];
                    for (const segment of segments) {
                        if (isStoppingGenerationRef.current) break;
                        displayedAiText += segment;
                        setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { ...m, text: displayedAiText, isLoading: true } : m));
                        await new Promise(resolve => setTimeout(resolve, Math.max(1, Math.min(10, segment.length * 1.2)))); 
                    }
                    if (isStoppingGenerationRef.current) break;
                }
                setChatMessages(prev => prev.map(m => {
                    if (m.id === targetAiMessageId) {
                        let finalText = displayedAiText;
                        if (isStoppingGenerationRef.current && !finalText.includes("Generation stopped by user.")) {
                            finalText += (finalText ? "\n\n---\n" : "") + "*Generation stopped by user.*";
                        } else if (!finalText.trim() && !isStoppingGenerationRef.current) {
                            finalText = "*Koi jawab nahi mila.*";
                        }
                        return { ...m, text: finalText, isLoading: false };
                    }
                    return m;
                }));
            } catch (err) { 
                console.error("AI stream error in _streamAiResponse:", err); 
                const errorText = err.message || "An unknown error occurred during streaming."; 
                setChatError(errorText); 
                setChatMessages(prev => prev.map(m => m.id === targetAiMessageId ? { ...m, role: 'system', text: `Mazrat: ${errorText}`, isLoading: false } : m));
            } finally { 
                setIsChatLoading(false); 
                isStoppingGenerationRef.current = false; 
            }
        };

        const handleSendChatMessage = useCallback(async (messageText, filesToSend) => {
            if (!messageText.trim() && filesToSend.length === 0) return;
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") { setChatError("Gemini API Key is not configured."); return; }
            setChatError(null);

            const previousInternalMessages = chatMessages; 

            const userMessageFiles = filesToSend.map(f => ({ id: f.id, name: f.name, type: f.type, apiData: f.apiData }));
            const newUserMessage = { id: Date.now().toString() + '_user', role: 'user', text: messageText, timestamp: new Date(), attachedFiles: userMessageFiles };
            const aiMessageId = Date.now().toString() + '_model_resp';
            const aiPlaceholder = { id: aiMessageId, role: 'model', text: '', timestamp: new Date(), isLoading: true };
            
            setChatMessages(prev => { 
              const filteredPrev = prev.filter(m => !(m.id?.includes("_sys_")));
              return [...filteredPrev, newUserMessage, aiPlaceholder];
            });
            
            const promptPartsForCurrentTurn = [];
            if (messageText.trim()) promptPartsForCurrentTurn.push({ text: messageText.trim() });
            filesToSend.forEach(file => {
                if (file.type.startsWith('image/') && file.apiData.mimeType && file.apiData.data) { promptPartsForCurrentTurn.push({ inlineData: file.apiData }); } 
                else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData.textContent) { promptPartsForCurrentTurn.push({ text: `\n[Start of Text File: ${file.name}]\n${file.apiData.textContent}\n[End of Text File: ${file.name}]\n` }); }
            });
            
            if (promptPartsForCurrentTurn.length > 0) {
                 const historyForGeminiInit = getGeminiHistory(previousInternalMessages);
                 await _streamAiResponse(promptPartsForCurrentTurn, aiMessageId, historyForGeminiInit);
            } else { 
                setChatMessages(prev => prev.filter(msg => msg.id !== aiMessageId)); 
                setIsChatLoading(false);
                setChatError("No content to send.");
            }
        }, [chatMessages]); 

        const handleRegenerateResponse = useCallback(async (aiMessageIdToRegenerate) => {
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") { setChatError("API Key not configured."); return; }
            
            const originalAiMsgIndex = chatMessages.findIndex(m => m.id === aiMessageIdToRegenerate);
            if (originalAiMsgIndex <= 0 || chatMessages[originalAiMsgIndex-1].role !== 'user') { 
              setChatError("Cannot regenerate this message. Preceding user prompt not found."); return; 
            }
            
            const userPromptMsg = chatMessages[originalAiMsgIndex-1];
            if (userPromptMsg.attachedFiles?.some(f => f.type?.startsWith('image/'))) { 
                 setChatError("Tasveer walay sawalon ke liye regenerate abhi dastyaab nahi hai."); return;
            }
            
            const newAiPlaceholderId = Date.now().toString() + '_model_regen';
            const aiPlaceholder = { id: newAiPlaceholderId, role: 'model', text:'', isLoading:true, timestamp:new Date() };
            
            const chatHistoryForUiUpdate = chatMessages.slice(0, originalAiMsgIndex); 
            setChatMessages([...chatHistoryForUiUpdate, aiPlaceholder]);

            const promptPartsForCurrentTurn = [];
            if (userPromptMsg.text) promptPartsForCurrentTurn.push({ text: userPromptMsg.text });
            userPromptMsg.attachedFiles?.forEach(file => {
                if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent) {
                     promptPartsForCurrentTurn.push({ text: `\n[Start of Text File: ${file.name}]\n${file.apiData.textContent}\n[End of Text File: ${file.name}]\n` });
                }
            });

            if (promptPartsForCurrentTurn.length > 0) {
                const historyBeforeUserPromptInternal = chatMessages.slice(0, originalAiMsgIndex - 1);
                const historyForGeminiInit = getGeminiHistory(historyBeforeUserPromptInternal);
                await _streamAiResponse(promptPartsForCurrentTurn, newAiPlaceholderId, historyForGeminiInit);
            } else {
                 setChatError("Regenerate ke liye koi content nahi mila.");
                 setChatMessages(prev => prev.map(m => m.id === newAiPlaceholderId ? {...m, isLoading: false, text: "Regeneration failed: No prompt content."} : m));
            }
        }, [chatMessages]);

        return (
          <div className="h-full text-text-primary flex flex-col font-sans items-center justify-start sm:justify-center p-0">
            <ChatInterface 
              messages={chatMessages} 
              onSendMessage={handleSendChatMessage} 
              isLoading={isChatLoading} 
              error={chatError} 
              onStopGeneration={handleStopGeneration} 
              onRegenerate={handleRegenerateResponse} 
              onClearChat={handleClearChat}
              setChatError={setChatError}
            />
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>
